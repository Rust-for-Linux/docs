<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="String slices."><meta name="keywords" content="rust, rustlang, rust-lang, str"><title>str - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../logo.svg"></head><body class="rustdoc primitive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../core/index.html"><div class="logo-container"><img class="rust-logo" src="../logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../core/index.html"><div class="logo-container"><img class="rust-logo" src="../logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">str</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.as_bytes">as_bytes</a></li><li><a href="#method.as_bytes_mut">as_bytes_mut</a></li><li><a href="#method.as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.as_ptr">as_ptr</a></li><li><a href="#method.bytes">bytes</a></li><li><a href="#method.ceil_char_boundary">ceil_char_boundary</a></li><li><a href="#method.char_indices">char_indices</a></li><li><a href="#method.chars">chars</a></li><li><a href="#method.contains">contains</a></li><li><a href="#method.encode_utf16">encode_utf16</a></li><li><a href="#method.ends_with">ends_with</a></li><li><a href="#method.eq_ignore_ascii_case">eq_ignore_ascii_case</a></li><li><a href="#method.escape_debug">escape_debug</a></li><li><a href="#method.escape_default">escape_default</a></li><li><a href="#method.escape_unicode">escape_unicode</a></li><li><a href="#method.find">find</a></li><li><a href="#method.floor_char_boundary">floor_char_boundary</a></li><li><a href="#method.get">get</a></li><li><a href="#method.get_mut">get_mut</a></li><li><a href="#method.get_unchecked">get_unchecked</a></li><li><a href="#method.get_unchecked_mut">get_unchecked_mut</a></li><li><a href="#method.is_ascii">is_ascii</a></li><li><a href="#method.is_char_boundary">is_char_boundary</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.len">len</a></li><li><a href="#method.lines">lines</a></li><li><a href="#method.lines_any">lines_any</a></li><li><a href="#method.make_ascii_lowercase">make_ascii_lowercase</a></li><li><a href="#method.make_ascii_uppercase">make_ascii_uppercase</a></li><li><a href="#method.match_indices">match_indices</a></li><li><a href="#method.matches">matches</a></li><li><a href="#method.parse">parse</a></li><li><a href="#method.rfind">rfind</a></li><li><a href="#method.rmatch_indices">rmatch_indices</a></li><li><a href="#method.rmatches">rmatches</a></li><li><a href="#method.rsplit">rsplit</a></li><li><a href="#method.rsplit_once">rsplit_once</a></li><li><a href="#method.rsplit_terminator">rsplit_terminator</a></li><li><a href="#method.rsplitn">rsplitn</a></li><li><a href="#method.slice_mut_unchecked">slice_mut_unchecked</a></li><li><a href="#method.slice_unchecked">slice_unchecked</a></li><li><a href="#method.split">split</a></li><li><a href="#method.split_ascii_whitespace">split_ascii_whitespace</a></li><li><a href="#method.split_at">split_at</a></li><li><a href="#method.split_at_mut">split_at_mut</a></li><li><a href="#method.split_inclusive">split_inclusive</a></li><li><a href="#method.split_once">split_once</a></li><li><a href="#method.split_terminator">split_terminator</a></li><li><a href="#method.split_whitespace">split_whitespace</a></li><li><a href="#method.splitn">splitn</a></li><li><a href="#method.starts_with">starts_with</a></li><li><a href="#method.strip_prefix">strip_prefix</a></li><li><a href="#method.strip_suffix">strip_suffix</a></li><li><a href="#method.trim">trim</a></li><li><a href="#method.trim_end">trim_end</a></li><li><a href="#method.trim_end_matches">trim_end_matches</a></li><li><a href="#method.trim_left">trim_left</a></li><li><a href="#method.trim_left_matches">trim_left_matches</a></li><li><a href="#method.trim_matches">trim_matches</a></li><li><a href="#method.trim_right">trim_right</a></li><li><a href="#method.trim_right_matches">trim_right_matches</a></li><li><a href="#method.trim_start">trim_start</a></li><li><a href="#method.trim_start_matches">trim_start_matches</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-AsMut%3Cstr%3E">AsMut&lt;str&gt;</a></li><li><a href="#impl-AsRef%3C%5Bu8%5D%3E">AsRef&lt;[u8]&gt;</a></li><li><a href="#impl-AsRef%3Cstr%3E">AsRef&lt;str&gt;</a></li><li><a href="#impl-Debug">Debug</a></li><li><a href="#impl-Default">Default</a></li><li><a href="#impl-Default-1">Default</a></li><li><a href="#impl-Display">Display</a></li><li><a href="#impl-Eq">Eq</a></li><li><a href="#impl-Hash">Hash</a></li><li><a href="#impl-Index%3CI%3E">Index&lt;I&gt;</a></li><li><a href="#impl-IndexMut%3CI%3E">IndexMut&lt;I&gt;</a></li><li><a href="#impl-Ord">Ord</a></li><li><a href="#impl-PartialEq%3Cstr%3E">PartialEq&lt;str&gt;</a></li><li><a href="#impl-PartialOrd%3Cstr%3E">PartialOrd&lt;str&gt;</a></li><li><a href="#impl-Pattern%3C%27a%3E">Pattern&lt;&#39;a&gt;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E">SliceIndex&lt;str&gt;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-1">SliceIndex&lt;str&gt;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-2">SliceIndex&lt;str&gt;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-3">SliceIndex&lt;str&gt;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-4">SliceIndex&lt;str&gt;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-5">SliceIndex&lt;str&gt;</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send">Send</a></li><li><a href="#impl-Sized">!Sized</a></li><li><a href="#impl-Sync">Sync</a></li><li><a href="#impl-Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe">UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In core</a></h2><div id="sidebar-vars" data-name="str" data-ty="primitive" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../core/index.html"><img class="rust-logo" src="../logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Primitive Type <a class="primitive" href="#">str</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>String slices.</p>
<p><em><a href="str/index.html">See also the <code>std::str</code> module</a>.</em></p>
<p>The <code>str</code> type, also called a â€˜string sliceâ€™, is the most primitive string
type. It is usually seen in its borrowed form, <code>&amp;str</code>. It is also the type
of string literals, <code>&amp;'static str</code>.</p>
<p>String slices are always valid UTF-8.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<p>String literals are string slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">hello</span> <span class="op">=</span> <span class="string">&quot;Hello, world!&quot;</span>;

<span class="comment">// with an explicit type annotation</span>
<span class="kw">let</span> <span class="ident">hello</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20hello%20%3D%20%22Hello%2C%20world!%22%3B%0A%0A%2F%2F%20with%20an%20explicit%20type%20annotation%0Alet%20hello%3A%20%26'static%20str%20%3D%20%22Hello%2C%20world!%22%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>They are <code>'static</code> because theyâ€™re stored directly in the final binary, and
so will be valid for the <code>'static</code> duration.</p>
<h2 id="representation"><a href="#representation">Representation</a></h2>
<p>A <code>&amp;str</code> is made up of two components: a pointer to some bytes, and a
length. You can look at these with the <a href="primitive.str.html#method.as_ptr"><code>as_ptr</code></a> and <a href="primitive.str.html#method.len"><code>len</code></a> methods:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::slice</span>;
<span class="kw">use</span> <span class="ident">std::str</span>;

<span class="kw">let</span> <span class="ident">story</span> <span class="op">=</span> <span class="string">&quot;Once upon a time...&quot;</span>;

<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">story</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="ident">story</span>.<span class="ident">len</span>();

<span class="comment">// story has nineteen bytes</span>
<span class="macro">assert_eq!</span>(<span class="number">19</span>, <span class="ident">len</span>);

<span class="comment">// We can re-build a str out of ptr and len. This is all unsafe because</span>
<span class="comment">// we are responsible for making sure the two components are valid:</span>
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="comment">// First, we build a &amp;[u8]...</span>
    <span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="ident">slice::from_raw_parts</span>(<span class="ident">ptr</span>, <span class="ident">len</span>);

    <span class="comment">// ... and then convert that slice into a string slice</span>
    <span class="ident">str::from_utf8</span>(<span class="ident">slice</span>)
};

<span class="macro">assert_eq!</span>(<span class="ident">s</span>, <span class="prelude-val">Ok</span>(<span class="ident">story</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aslice%3B%0Ause%20std%3A%3Astr%3B%0A%0Alet%20story%20%3D%20%22Once%20upon%20a%20time...%22%3B%0A%0Alet%20ptr%20%3D%20story.as_ptr()%3B%0Alet%20len%20%3D%20story.len()%3B%0A%0A%2F%2F%20story%20has%20nineteen%20bytes%0Aassert_eq!(19%2C%20len)%3B%0A%0A%2F%2F%20We%20can%20re-build%20a%20str%20out%20of%20ptr%20and%20len.%20This%20is%20all%20unsafe%20because%0A%2F%2F%20we%20are%20responsible%20for%20making%20sure%20the%20two%20components%20are%20valid%3A%0Alet%20s%20%3D%20unsafe%20%7B%0A%20%20%20%20%2F%2F%20First%2C%20we%20build%20a%20%26%5Bu8%5D...%0A%20%20%20%20let%20slice%20%3D%20slice%3A%3Afrom_raw_parts(ptr%2C%20len)%3B%0A%0A%20%20%20%20%2F%2F%20...%20and%20then%20convert%20that%20slice%20into%20a%20string%20slice%0A%20%20%20%20str%3A%3Afrom_utf8(slice)%0A%7D%3B%0A%0Aassert_eq!(s%2C%20Ok(story))%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Note: This example shows the internals of <code>&amp;str</code>. <code>unsafe</code> should not be
used to get a string slice under normal circumstances. Use <code>as_str</code>
instead.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#134-2557">source</a></span><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.len" class="method has-srclink"><span class="rightside"><span class="since" title="const since 1.39.0">const: 1.39.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#157-159">source</a></span><a href="#method.len" class="anchor"></a><h4 class="code-header">pub const fn <a href="#method.len" class="fnname">len</a>(&amp;self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the length of <code>self</code>.</p>
<p>This length is in bytes, not <a href="primitive.char.html"><code>char</code></a>s or graphemes. In other words,
it might not be what a human considers the length of the string.</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="string">&quot;foo&quot;</span>.<span class="ident">len</span>();
<span class="macro">assert_eq!</span>(<span class="number">3</span>, <span class="ident">len</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;Æ’oo&quot;</span>.<span class="ident">len</span>(), <span class="number">4</span>); <span class="comment">// fancy f!</span>
<span class="macro">assert_eq!</span>(<span class="string">&quot;Æ’oo&quot;</span>.<span class="ident">chars</span>().<span class="ident">count</span>(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20len%20%3D%20%22foo%22.len()%3B%0Aassert_eq!(3%2C%20len)%3B%0A%0Aassert_eq!(%22%C6%92oo%22.len()%2C%204)%3B%20%2F%2F%20fancy%20f!%0Aassert_eq!(%22%C6%92oo%22.chars().count()%2C%203)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_empty" class="method has-srclink"><span class="rightside"><span class="since" title="const since 1.39.0">const: 1.39.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#178-180">source</a></span><a href="#method.is_empty" class="anchor"></a><h4 class="code-header">pub const fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>;
<span class="macro">assert!</span>(<span class="ident">s</span>.<span class="ident">is_empty</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;not empty&quot;</span>;
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_empty</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%22%3B%0Aassert!(s.is_empty())%3B%0A%0Alet%20s%20%3D%20%22not%20empty%22%3B%0Aassert!(!s.is_empty())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_char_boundary" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0, const unstable">1.9.0 (const: unstable)</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#209-232">source</a></span><a href="#method.is_char_boundary" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.is_char_boundary" class="fnname">is_char_boundary</a>(&amp;self, index: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks that <code>index</code>-th byte is the first byte in a UTF-8 code point
sequence or the end of the string.</p>
<p>The start and end of the string (when <code>index == self.len()</code>) are
considered to be boundaries.</p>
<p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;
<span class="macro">assert!</span>(<span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">0</span>));
<span class="comment">// start of `è€`</span>
<span class="macro">assert!</span>(<span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">6</span>));
<span class="macro">assert!</span>(<span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="ident">s</span>.<span class="ident">len</span>()));

<span class="comment">// second byte of `Ã¶`</span>
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">2</span>));

<span class="comment">// third byte of `è€`</span>
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">8</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%22%3B%0Aassert!(s.is_char_boundary(0))%3B%0A%2F%2F%20start%20of%20%60%E8%80%81%60%0Aassert!(s.is_char_boundary(6))%3B%0Aassert!(s.is_char_boundary(s.len()))%3B%0A%0A%2F%2F%20second%20byte%20of%20%60%C3%B6%60%0Aassert!(!s.is_char_boundary(2))%3B%0A%0A%2F%2F%20third%20byte%20of%20%60%E8%80%81%60%0Aassert!(!s.is_char_boundary(8))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.floor_char_boundary" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#256-268">source</a></span><a href="#method.floor_char_boundary" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.floor_char_boundary" class="fnname">floor_char_boundary</a>(&amp;self, index: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>round_char_boundary</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/93743">#93743</a>)</div></span></summary><div class="docblock"><p>Finds the closest <code>x</code> not exceeding <code>index</code> where <code>is_char_boundary(x)</code> is <code>true</code>.</p>
<p>This method can help you truncate a string so that itâ€™s still valid UTF-8, but doesnâ€™t
exceed a given number of bytes. Note that this is done purely at the character level
and can still visually split graphemes, even though the underlying characters arenâ€™t
split. For example, the emoji ğŸ§‘â€ğŸ”¬ (scientist) could be split so that the string only
includes ğŸ§‘ (person) instead.</p>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">round_char_boundary</span>)]</span>
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;â¤ï¸ğŸ§¡ğŸ’›ğŸ’šğŸ’™ğŸ’œ&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">len</span>(), <span class="number">26</span>);
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">13</span>));

<span class="kw">let</span> <span class="ident">closest</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">floor_char_boundary</span>(<span class="number">13</span>);
<span class="macro">assert_eq!</span>(<span class="ident">closest</span>, <span class="number">10</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">s</span>[..<span class="ident">closest</span>], <span class="string">&quot;â¤ï¸ğŸ§¡&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(round_char_boundary)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%F0%9F%92%9B%F0%9F%92%9A%F0%9F%92%99%F0%9F%92%9C%22%3B%0Aassert_eq!(s.len()%2C%2026)%3B%0Aassert!(!s.is_char_boundary(13))%3B%0A%0Alet%20closest%20%3D%20s.floor_char_boundary(13)%3B%0Aassert_eq!(closest%2C%2010)%3B%0Aassert_eq!(%26s%5B..closest%5D%2C%20%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%22)%3B%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ceil_char_boundary" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#295-305">source</a></span><a href="#method.ceil_char_boundary" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.ceil_char_boundary" class="fnname">ceil_char_boundary</a>(&amp;self, index: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>round_char_boundary</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/93743">#93743</a>)</div></span></summary><div class="docblock"><p>Finds the closest <code>x</code> not below <code>index</code> where <code>is_char_boundary(x)</code> is <code>true</code>.</p>
<p>This method is the natural complement to <a href="primitive.str.html#method.floor_char_boundary"><code>floor_char_boundary</code></a>. See that method
for more details.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>Panics if <code>index &gt; self.len()</code>.</p>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">round_char_boundary</span>)]</span>
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;â¤ï¸ğŸ§¡ğŸ’›ğŸ’šğŸ’™ğŸ’œ&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">len</span>(), <span class="number">26</span>);
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">13</span>));

<span class="kw">let</span> <span class="ident">closest</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">ceil_char_boundary</span>(<span class="number">13</span>);
<span class="macro">assert_eq!</span>(<span class="ident">closest</span>, <span class="number">14</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">s</span>[..<span class="ident">closest</span>], <span class="string">&quot;â¤ï¸ğŸ§¡ğŸ’›&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(round_char_boundary)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%F0%9F%92%9B%F0%9F%92%9A%F0%9F%92%99%F0%9F%92%9C%22%3B%0Aassert_eq!(s.len()%2C%2026)%3B%0Aassert!(!s.is_char_boundary(13))%3B%0A%0Alet%20closest%20%3D%20s.ceil_char_boundary(13)%3B%0Aassert_eq!(closest%2C%2014)%3B%0Aassert_eq!(%26s%5B..closest%5D%2C%20%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%F0%9F%92%9B%22)%3B%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_bytes" class="method has-srclink"><span class="rightside"><span class="since" title="const since 1.39.0">const: 1.39.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#323-326">source</a></span><a href="#method.as_bytes" class="anchor"></a><h4 class="code-header">pub const fn <a href="#method.as_bytes" class="fnname">as_bytes</a>(&amp;self) -&gt; <a class="primitive" href="primitive.slice.html">&amp;[</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a></h4></section></summary><div class="docblock"><p>Converts a string slice to a byte slice. To convert the byte slice back
into a string slice, use the <a href="str/fn.from_utf8.html" title="from_utf8"><code>from_utf8</code></a> function.</p>
<h5 id="examples-6"><a href="#examples-6">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">&quot;bors&quot;</span>.<span class="ident">as_bytes</span>();
<span class="macro">assert_eq!</span>(<span class="string">b&quot;bors&quot;</span>, <span class="ident">bytes</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20bytes%20%3D%20%22bors%22.as_bytes()%3B%0Aassert_eq!(b%22bors%22%2C%20bytes)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_bytes_mut" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#367-373">source</a></span><a href="#method.as_bytes_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.as_bytes_mut" class="fnname">as_bytes_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.slice.html">&amp;mut [</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a></h4></section></summary><div class="docblock"><p>Converts a mutable string slice to a mutable byte slice.</p>
<h5 id="safety"><a href="#safety">Safety</a></h5>
<p>The caller must ensure that the content of the slice is valid UTF-8
before the borrow ends and the underlying <code>str</code> is used.</p>
<p>Use of a <code>str</code> whose contents are not valid UTF-8 is undefined behavior.</p>
<h5 id="examples-7"><a href="#examples-7">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;Hello&quot;</span>);
<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">s</span>.<span class="ident">as_bytes_mut</span>() };

<span class="macro">assert_eq!</span>(<span class="string">b&quot;Hello&quot;</span>, <span class="ident">bytes</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20String%3A%3Afrom(%22Hello%22)%3B%0Alet%20bytes%20%3D%20unsafe%20%7B%20s.as_bytes_mut()%20%7D%3B%0A%0Aassert_eq!(b%22Hello%22%2C%20bytes)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Mutability:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;ğŸ—»âˆˆğŸŒ&quot;</span>);

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_bytes_mut</span>();

    <span class="ident">bytes</span>[<span class="number">0</span>] <span class="op">=</span> <span class="number">0xF0</span>;
    <span class="ident">bytes</span>[<span class="number">1</span>] <span class="op">=</span> <span class="number">0x9F</span>;
    <span class="ident">bytes</span>[<span class="number">2</span>] <span class="op">=</span> <span class="number">0x8D</span>;
    <span class="ident">bytes</span>[<span class="number">3</span>] <span class="op">=</span> <span class="number">0x94</span>;
}

<span class="macro">assert_eq!</span>(<span class="string">&quot;ğŸ”âˆˆğŸŒ&quot;</span>, <span class="ident">s</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20String%3A%3Afrom(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22)%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20let%20bytes%20%3D%20s.as_bytes_mut()%3B%0A%0A%20%20%20%20bytes%5B0%5D%20%3D%200xF0%3B%0A%20%20%20%20bytes%5B1%5D%20%3D%200x9F%3B%0A%20%20%20%20bytes%5B2%5D%20%3D%200x8D%3B%0A%20%20%20%20bytes%5B3%5D%20%3D%200x94%3B%0A%7D%0A%0Aassert_eq!(%22%F0%9F%8D%94%E2%88%88%F0%9F%8C%8F%22%2C%20s)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ptr" class="method has-srclink"><span class="rightside"><span class="since" title="const since 1.32.0">const: 1.32.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#398-400">source</a></span><a href="#method.as_ptr" class="anchor"></a><h4 class="code-header">pub const fn <a href="#method.as_ptr" class="fnname">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.u8.html">u8</a></h4></section></summary><div class="docblock"><p>Converts a string slice to a raw pointer.</p>
<p>As string slices are a slice of bytes, the raw pointer points to a
<a href="primitive.u8.html" title="u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string
slice.</p>
<p>The caller must ensure that the returned pointer is never written to.
If you need to mutate the contents of the string slice, use <a href="primitive.str.html#method.as_mut_ptr"><code>as_mut_ptr</code></a>.</p>
<h5 id="examples-8"><a href="#examples-8">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Hello&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22Hello%22%3B%0Alet%20ptr%20%3D%20s.as_ptr()%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_ptr" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#413-415">source</a></span><a href="#method.as_mut_ptr" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fnname">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.u8.html">u8</a></h4></section></summary><div class="docblock"><p>Converts a mutable string slice to a raw pointer.</p>
<p>As string slices are a slice of bytes, the raw pointer points to a
<a href="primitive.u8.html" title="u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string
slice.</p>
<p>It is your responsibility to make sure that the string slice only gets
modified in a way that it remains valid UTF-8.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#439-441">source</a></span><a href="#method.get" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get" class="fnname">get</a>&lt;I:&nbsp;<a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;(&amp;self, i: I) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;I::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a subslice of <code>str</code>.</p>
<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns
<a href="option/enum.Option.html#variant.None" title="None"><code>None</code></a> whenever equivalent indexing operation would panic.</p>
<h5 id="examples-9"><a href="#examples-9">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;ğŸ—»âˆˆğŸŒ&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;ğŸ—»&quot;</span>), <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">0</span>..<span class="number">4</span>));

<span class="comment">// indices not on UTF-8 sequence boundaries</span>
<span class="macro">assert!</span>(<span class="ident">v</span>.<span class="ident">get</span>(<span class="number">1</span>..).<span class="ident">is_none</span>());
<span class="macro">assert!</span>(<span class="ident">v</span>.<span class="ident">get</span>(..<span class="number">8</span>).<span class="ident">is_none</span>());

<span class="comment">// out of bounds</span>
<span class="macro">assert!</span>(<span class="ident">v</span>.<span class="ident">get</span>(..<span class="number">42</span>).<span class="ident">is_none</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%20%3D%20String%3A%3Afrom(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22)%3B%0A%0Aassert_eq!(Some(%22%F0%9F%97%BB%22)%2C%20v.get(0..4))%3B%0A%0A%2F%2F%20indices%20not%20on%20UTF-8%20sequence%20boundaries%0Aassert!(v.get(1..).is_none())%3B%0Aassert!(v.get(..8).is_none())%3B%0A%0A%2F%2F%20out%20of%20bounds%0Aassert!(v.get(..42).is_none())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_mut" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#472-474">source</a></span><a href="#method.get_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fnname">get_mut</a>&lt;I:&nbsp;<a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;(&amp;mut self, i: I) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut I::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a mutable subslice of <code>str</code>.</p>
<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns
<a href="option/enum.Option.html#variant.None" title="None"><code>None</code></a> whenever equivalent indexing operation would panic.</p>
<h5 id="examples-10"><a href="#examples-10">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;hello&quot;</span>);
<span class="comment">// correct length</span>
<span class="macro">assert!</span>(<span class="ident">v</span>.<span class="ident">get_mut</span>(<span class="number">0</span>..<span class="number">5</span>).<span class="ident">is_some</span>());
<span class="comment">// out of bounds</span>
<span class="macro">assert!</span>(<span class="ident">v</span>.<span class="ident">get_mut</span>(..<span class="number">42</span>).<span class="ident">is_none</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;he&quot;</span>), <span class="ident">v</span>.<span class="ident">get_mut</span>(<span class="number">0</span>..<span class="number">2</span>).<span class="ident">map</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">v</span>));

<span class="macro">assert_eq!</span>(<span class="string">&quot;hello&quot;</span>, <span class="ident">v</span>);
{
    <span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">get_mut</span>(<span class="number">0</span>..<span class="number">2</span>);
    <span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">map</span>(<span class="op">|</span><span class="ident">s</span><span class="op">|</span> {
        <span class="ident">s</span>.<span class="ident">make_ascii_uppercase</span>();
        <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">s</span>
    });
    <span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;HE&quot;</span>), <span class="ident">s</span>);
}
<span class="macro">assert_eq!</span>(<span class="string">&quot;HEllo&quot;</span>, <span class="ident">v</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20v%20%3D%20String%3A%3Afrom(%22hello%22)%3B%0A%2F%2F%20correct%20length%0Aassert!(v.get_mut(0..5).is_some())%3B%0A%2F%2F%20out%20of%20bounds%0Aassert!(v.get_mut(..42).is_none())%3B%0Aassert_eq!(Some(%22he%22)%2C%20v.get_mut(0..2).map(%7Cv%7C%20%26*v))%3B%0A%0Aassert_eq!(%22hello%22%2C%20v)%3B%0A%7B%0A%20%20%20%20let%20s%20%3D%20v.get_mut(0..2)%3B%0A%20%20%20%20let%20s%20%3D%20s.map(%7Cs%7C%20%7B%0A%20%20%20%20%20%20%20%20s.make_ascii_uppercase()%3B%0A%20%20%20%20%20%20%20%20%26*s%0A%20%20%20%20%7D)%3B%0A%20%20%20%20assert_eq!(Some(%22HE%22)%2C%20s)%3B%0A%7D%0Aassert_eq!(%22HEllo%22%2C%20v)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#505-510">source</a></span><a href="#method.get_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fnname">get_unchecked</a>&lt;I:&nbsp;<a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;(&amp;self, i: I) -&gt; &amp;I::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><div class="docblock"><p>Returns an unchecked subslice of <code>str</code>.</p>
<p>This is the unchecked alternative to indexing the <code>str</code>.</p>
<h5 id="safety-1"><a href="#safety-1">Safety</a></h5>
<p>Callers of this function are responsible that these preconditions are
satisfied:</p>
<ul>
<li>The starting index must not exceed the ending index;</li>
<li>Indexes must be within bounds of the original slice;</li>
<li>Indexes must lie on UTF-8 sequence boundaries.</li>
</ul>
<p>Failing that, the returned string slice may reference invalid memory or
violate the invariants communicated by the <code>str</code> type.</p>
<h5 id="examples-11"><a href="#examples-11">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="string">&quot;ğŸ—»âˆˆğŸŒ&quot;</span>;
<span class="kw">unsafe</span> {
    <span class="macro">assert_eq!</span>(<span class="string">&quot;ğŸ—»&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked</span>(<span class="number">0</span>..<span class="number">4</span>));
    <span class="macro">assert_eq!</span>(<span class="string">&quot;âˆˆ&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked</span>(<span class="number">4</span>..<span class="number">7</span>));
    <span class="macro">assert_eq!</span>(<span class="string">&quot;ğŸŒ&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked</span>(<span class="number">7</span>..<span class="number">11</span>));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%20%3D%20%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22%3B%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(%22%F0%9F%97%BB%22%2C%20v.get_unchecked(0..4))%3B%0A%20%20%20%20assert_eq!(%22%E2%88%88%22%2C%20v.get_unchecked(4..7))%3B%0A%20%20%20%20assert_eq!(%22%F0%9F%8C%8F%22%2C%20v.get_unchecked(7..11))%3B%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked_mut" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#541-549">source</a></span><a href="#method.get_unchecked_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked_mut" class="fnname">get_unchecked_mut</a>&lt;I:&nbsp;<a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;i: I<br>) -&gt; &amp;mut I::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><div class="docblock"><p>Returns a mutable, unchecked subslice of <code>str</code>.</p>
<p>This is the unchecked alternative to indexing the <code>str</code>.</p>
<h5 id="safety-2"><a href="#safety-2">Safety</a></h5>
<p>Callers of this function are responsible that these preconditions are
satisfied:</p>
<ul>
<li>The starting index must not exceed the ending index;</li>
<li>Indexes must be within bounds of the original slice;</li>
<li>Indexes must lie on UTF-8 sequence boundaries.</li>
</ul>
<p>Failing that, the returned string slice may reference invalid memory or
violate the invariants communicated by the <code>str</code> type.</p>
<h5 id="examples-12"><a href="#examples-12">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;ğŸ—»âˆˆğŸŒ&quot;</span>);
<span class="kw">unsafe</span> {
    <span class="macro">assert_eq!</span>(<span class="string">&quot;ğŸ—»&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked_mut</span>(<span class="number">0</span>..<span class="number">4</span>));
    <span class="macro">assert_eq!</span>(<span class="string">&quot;âˆˆ&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked_mut</span>(<span class="number">4</span>..<span class="number">7</span>));
    <span class="macro">assert_eq!</span>(<span class="string">&quot;ğŸŒ&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked_mut</span>(<span class="number">7</span>..<span class="number">11</span>));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20v%20%3D%20String%3A%3Afrom(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22)%3B%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(%22%F0%9F%97%BB%22%2C%20v.get_unchecked_mut(0..4))%3B%0A%20%20%20%20assert_eq!(%22%E2%88%88%22%2C%20v.get_unchecked_mut(4..7))%3B%0A%20%20%20%20assert_eq!(%22%F0%9F%8C%8F%22%2C%20v.get_unchecked_mut(7..11))%3B%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.slice_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#597-602">source</a></span><a href="#method.slice_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.slice_unchecked" class="fnname">slice_unchecked</a>(&amp;self, begin: <a class="primitive" href="primitive.usize.html">usize</a>, end: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.29.0: <p>use <code>get_unchecked(begin..end)</code> instead</p>
</div></span></summary><div class="docblock"><p>Creates a string slice from another string slice, bypassing safety
checks.</p>
<p>This is generally not recommended, use with caution! For a safe
alternative see <a href="primitive.str.html" title="str"><code>str</code></a> and <a href="ops/trait.Index.html"><code>Index</code></a>.</p>
<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but
excluding <code>end</code>.</p>
<p>To get a mutable string slice instead, see the
<a href="primitive.str.html#method.slice_mut_unchecked"><code>slice_mut_unchecked</code></a> method.</p>
<h5 id="safety-3"><a href="#safety-3">Safety</a></h5>
<p>Callers of this function are responsible that three preconditions are
satisfied:</p>
<ul>
<li><code>begin</code> must not exceed <code>end</code>.</li>
<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>
<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>
</ul>
<h5 id="examples-13"><a href="#examples-13">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;

<span class="kw">unsafe</span> {
    <span class="macro">assert_eq!</span>(<span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>, <span class="ident">s</span>.<span class="ident">slice_unchecked</span>(<span class="number">0</span>, <span class="number">21</span>));
}

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Hello, world!&quot;</span>;

<span class="kw">unsafe</span> {
    <span class="macro">assert_eq!</span>(<span class="string">&quot;world&quot;</span>, <span class="ident">s</span>.<span class="ident">slice_unchecked</span>(<span class="number">7</span>, <span class="number">12</span>));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%22%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%22%2C%20s.slice_unchecked(0%2C%2021))%3B%0A%7D%0A%0Alet%20s%20%3D%20%22Hello%2C%20world!%22%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(%22world%22%2C%20s.slice_unchecked(7%2C%2012))%3B%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.slice_mut_unchecked" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#630-635">source</a></span><a href="#method.slice_mut_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.slice_mut_unchecked" class="fnname">slice_mut_unchecked</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;begin: <a class="primitive" href="primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;end: <a class="primitive" href="primitive.usize.html">usize</a><br>) -&gt; &amp;mut <a class="primitive" href="primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.29.0: <p>use <code>get_unchecked_mut(begin..end)</code> instead</p>
</div></span></summary><div class="docblock"><p>Creates a string slice from another string slice, bypassing safety
checks.
This is generally not recommended, use with caution! For a safe
alternative see <a href="primitive.str.html" title="str"><code>str</code></a> and <a href="ops/trait.IndexMut.html"><code>IndexMut</code></a>.</p>
<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but
excluding <code>end</code>.</p>
<p>To get an immutable string slice instead, see the
<a href="primitive.str.html#method.slice_unchecked"><code>slice_unchecked</code></a> method.</p>
<h5 id="safety-4"><a href="#safety-4">Safety</a></h5>
<p>Callers of this function are responsible that three preconditions are
satisfied:</p>
<ul>
<li><code>begin</code> must not exceed <code>end</code>.</li>
<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>
<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#670-678">source</a></span><a href="#method.split_at" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_at" class="fnname">split_at</a>(&amp;self, mid: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.tuple.html">(</a>&amp;<a class="primitive" href="primitive.str.html">str</a>, &amp;<a class="primitive" href="primitive.str.html">str</a><a class="primitive" href="primitive.tuple.html">)</a></h4></section></summary><div class="docblock"><p>Divide one string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get mutable string slices instead, see the <a href="primitive.str.html#method.split_at_mut"><code>split_at_mut</code></a>
method.</p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is
past the end of the last code point of the string slice.</p>
<h5 id="examples-14"><a href="#examples-14">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Per Martin-LÃ¶f&quot;</span>;

<span class="kw">let</span> (<span class="ident">first</span>, <span class="ident">last</span>) <span class="op">=</span> <span class="ident">s</span>.<span class="ident">split_at</span>(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;Per&quot;</span>, <span class="ident">first</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot; Martin-LÃ¶f&quot;</span>, <span class="ident">last</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22Per%20Martin-L%C3%B6f%22%3B%0A%0Alet%20(first%2C%20last)%20%3D%20s.split_at(3)%3B%0A%0Aassert_eq!(%22Per%22%2C%20first)%3B%0Aassert_eq!(%22%20Martin-L%C3%B6f%22%2C%20last)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at_mut" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#714-729">source</a></span><a href="#method.split_at_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_at_mut" class="fnname">split_at_mut</a>(&amp;mut self, mid: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.tuple.html">(</a>&amp;mut <a class="primitive" href="primitive.str.html">str</a>, &amp;mut <a class="primitive" href="primitive.str.html">str</a><a class="primitive" href="primitive.tuple.html">)</a></h4></section></summary><div class="docblock"><p>Divide one mutable string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get immutable string slices instead, see the <a href="primitive.str.html#method.split_at"><code>split_at</code></a> method.</p>
<h5 id="panics-2"><a href="#panics-2">Panics</a></h5>
<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is
past the end of the last code point of the string slice.</p>
<h5 id="examples-15"><a href="#examples-15">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Per Martin-LÃ¶f&quot;</span>.<span class="ident">to_string</span>();
{
    <span class="kw">let</span> (<span class="ident">first</span>, <span class="ident">last</span>) <span class="op">=</span> <span class="ident">s</span>.<span class="ident">split_at_mut</span>(<span class="number">3</span>);
    <span class="ident">first</span>.<span class="ident">make_ascii_uppercase</span>();
    <span class="macro">assert_eq!</span>(<span class="string">&quot;PER&quot;</span>, <span class="ident">first</span>);
    <span class="macro">assert_eq!</span>(<span class="string">&quot; Martin-LÃ¶f&quot;</span>, <span class="ident">last</span>);
}
<span class="macro">assert_eq!</span>(<span class="string">&quot;PER Martin-LÃ¶f&quot;</span>, <span class="ident">s</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%22Per%20Martin-L%C3%B6f%22.to_string()%3B%0A%7B%0A%20%20%20%20let%20(first%2C%20last)%20%3D%20s.split_at_mut(3)%3B%0A%20%20%20%20first.make_ascii_uppercase()%3B%0A%20%20%20%20assert_eq!(%22PER%22%2C%20first)%3B%0A%20%20%20%20assert_eq!(%22%20Martin-L%C3%B6f%22%2C%20last)%3B%0A%7D%0Aassert_eq!(%22PER%20Martin-L%C3%B6f%22%2C%20s)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chars" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#780-782">source</a></span><a href="#method.chars" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.chars" class="fnname">chars</a>(&amp;self) -&gt; <a class="struct" href="str/struct.Chars.html" title="struct core::str::Chars">Chars</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.Chars.html" title="struct core::str::Chars">Chars</a>&lt;'a&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.Chars.html" title="struct core::str::Chars">Chars</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.char.html">char</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over the <a href="primitive.char.html"><code>char</code></a>s of a string slice.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="primitive.char.html"><code>char</code></a>. This method returns such an iterator.</p>
<p>Itâ€™s important to remember that <a href="primitive.char.html"><code>char</code></a> represents a Unicode Scalar
Value, and might not match your idea of what a â€˜characterâ€™ is. Iteration
over grapheme clusters may be what you actually want. This functionality
is not provided by Rustâ€™s standard library, check crates.io instead.</p>
<h5 id="examples-16"><a href="#examples-16">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">word</span> <span class="op">=</span> <span class="string">&quot;goodbye&quot;</span>;

<span class="kw">let</span> <span class="ident">count</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">chars</span>().<span class="ident">count</span>();
<span class="macro">assert_eq!</span>(<span class="number">7</span>, <span class="ident">count</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">chars</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">chars</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;g&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;o&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;o&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;d&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;b&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;y&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;e&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">chars</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20word%20%3D%20%22goodbye%22%3B%0A%0Alet%20count%20%3D%20word.chars().count()%3B%0Aassert_eq!(7%2C%20count)%3B%0A%0Alet%20mut%20chars%20%3D%20word.chars()%3B%0A%0Aassert_eq!(Some('g')%2C%20chars.next())%3B%0Aassert_eq!(Some('o')%2C%20chars.next())%3B%0Aassert_eq!(Some('o')%2C%20chars.next())%3B%0Aassert_eq!(Some('d')%2C%20chars.next())%3B%0Aassert_eq!(Some('b')%2C%20chars.next())%3B%0Aassert_eq!(Some('y')%2C%20chars.next())%3B%0Aassert_eq!(Some('e')%2C%20chars.next())%3B%0A%0Aassert_eq!(None%2C%20chars.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Remember, <a href="primitive.char.html"><code>char</code></a>s might not match your intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="string">&quot;yÌ†&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">chars</span> <span class="op">=</span> <span class="ident">y</span>.<span class="ident">chars</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;y&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>()); <span class="comment">// not &#39;yÌ†&#39;</span>
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;\u{0306}&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">chars</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20y%20%3D%20%22y%CC%86%22%3B%0A%0Alet%20mut%20chars%20%3D%20y.chars()%3B%0A%0Aassert_eq!(Some('y')%2C%20chars.next())%3B%20%2F%2F%20not%20'y%CC%86'%0Aassert_eq!(Some('%5Cu%7B0306%7D')%2C%20chars.next())%3B%0A%0Aassert_eq!(None%2C%20chars.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.char_indices" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#837-839">source</a></span><a href="#method.char_indices" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.char_indices" class="fnname">char_indices</a>(&amp;self) -&gt; <a class="struct" href="str/struct.CharIndices.html" title="struct core::str::CharIndices">CharIndices</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.CharIndices.html" title="struct core::str::CharIndices">CharIndices</a>&lt;'a&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.CharIndices.html" title="struct core::str::CharIndices">CharIndices</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.tuple.html">(</a><a class="primitive" href="primitive.usize.html">usize</a>, <a class="primitive" href="primitive.char.html">char</a><a class="primitive" href="primitive.tuple.html">)</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over the <a href="primitive.char.html"><code>char</code></a>s of a string slice, and their
positions.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="primitive.char.html"><code>char</code></a>. This method returns an iterator of both
these <a href="primitive.char.html"><code>char</code></a>s, as well as their byte positions.</p>
<p>The iterator yields tuples. The position is first, the <a href="primitive.char.html"><code>char</code></a> is
second.</p>
<h5 id="examples-17"><a href="#examples-17">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">word</span> <span class="op">=</span> <span class="string">&quot;goodbye&quot;</span>;

<span class="kw">let</span> <span class="ident">count</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">char_indices</span>().<span class="ident">count</span>();
<span class="macro">assert_eq!</span>(<span class="number">7</span>, <span class="ident">count</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">char_indices</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">char_indices</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">&#39;g&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">&#39;o&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">2</span>, <span class="string">&#39;o&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">&#39;d&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">&#39;b&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">5</span>, <span class="string">&#39;y&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">6</span>, <span class="string">&#39;e&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">char_indices</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20word%20%3D%20%22goodbye%22%3B%0A%0Alet%20count%20%3D%20word.char_indices().count()%3B%0Aassert_eq!(7%2C%20count)%3B%0A%0Alet%20mut%20char_indices%20%3D%20word.char_indices()%3B%0A%0Aassert_eq!(Some((0%2C%20'g'))%2C%20char_indices.next())%3B%0Aassert_eq!(Some((1%2C%20'o'))%2C%20char_indices.next())%3B%0Aassert_eq!(Some((2%2C%20'o'))%2C%20char_indices.next())%3B%0Aassert_eq!(Some((3%2C%20'd'))%2C%20char_indices.next())%3B%0Aassert_eq!(Some((4%2C%20'b'))%2C%20char_indices.next())%3B%0Aassert_eq!(Some((5%2C%20'y'))%2C%20char_indices.next())%3B%0Aassert_eq!(Some((6%2C%20'e'))%2C%20char_indices.next())%3B%0A%0Aassert_eq!(None%2C%20char_indices.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Remember, <a href="primitive.char.html"><code>char</code></a>s might not match your intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">yes</span> <span class="op">=</span> <span class="string">&quot;yÌ†es&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">char_indices</span> <span class="op">=</span> <span class="ident">yes</span>.<span class="ident">char_indices</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">&#39;y&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>()); <span class="comment">// not (0, &#39;yÌ†&#39;)</span>
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">&#39;\u{0306}&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());

<span class="comment">// note the 3 here - the last character took up two bytes</span>
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">&#39;e&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">&#39;s&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">char_indices</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20yes%20%3D%20%22y%CC%86es%22%3B%0A%0Alet%20mut%20char_indices%20%3D%20yes.char_indices()%3B%0A%0Aassert_eq!(Some((0%2C%20'y'))%2C%20char_indices.next())%3B%20%2F%2F%20not%20(0%2C%20'y%CC%86')%0Aassert_eq!(Some((1%2C%20'%5Cu%7B0306%7D'))%2C%20char_indices.next())%3B%0A%0A%2F%2F%20note%20the%203%20here%20-%20the%20last%20character%20took%20up%20two%20bytes%0Aassert_eq!(Some((3%2C%20'e'))%2C%20char_indices.next())%3B%0Aassert_eq!(Some((4%2C%20's'))%2C%20char_indices.next())%3B%0A%0Aassert_eq!(None%2C%20char_indices.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bytes" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#862-864">source</a></span><a href="#method.bytes" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.bytes" class="fnname">bytes</a>(&amp;self) -&gt; <a class="struct" href="str/struct.Bytes.html" title="struct core::str::Bytes">Bytes</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.Bytes.html" title="struct core::str::Bytes">Bytes</a>&lt;'_&gt;</span><code class="content"><span class="where fmt-newline">impl <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.Bytes.html" title="struct core::str::Bytes">Bytes</a>&lt;'_&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.u8.html">u8</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>An iterator over the bytes of a string slice.</p>
<p>As a string slice consists of a sequence of bytes, we can iterate
through a string slice by byte. This method returns such an iterator.</p>
<h5 id="examples-18"><a href="#examples-18">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">&quot;bors&quot;</span>.<span class="ident">bytes</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;b&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;o&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;r&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;s&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">bytes</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20bytes%20%3D%20%22bors%22.bytes()%3B%0A%0Aassert_eq!(Some(b'b')%2C%20bytes.next())%3B%0Aassert_eq!(Some(b'o')%2C%20bytes.next())%3B%0Aassert_eq!(Some(b'r')%2C%20bytes.next())%3B%0Aassert_eq!(Some(b's')%2C%20bytes.next())%3B%0A%0Aassert_eq!(None%2C%20bytes.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_whitespace" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#908-910">source</a></span><a href="#method.split_whitespace" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_whitespace" class="fnname">split_whitespace</a>(&amp;self) -&gt; <a class="struct" href="str/struct.SplitWhitespace.html" title="struct core::str::SplitWhitespace">SplitWhitespace</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.SplitWhitespace.html" title="struct core::str::SplitWhitespace">SplitWhitespace</a>&lt;'a&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.SplitWhitespace.html" title="struct core::str::SplitWhitespace">SplitWhitespace</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Splits a string slice by whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of whitespace.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>. If you only want to split on ASCII whitespace
instead, use <a href="primitive.str.html#method.split_ascii_whitespace"><code>split_ascii_whitespace</code></a>.</p>
<h5 id="examples-19"><a href="#examples-19">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="string">&quot;A few words&quot;</span>.<span class="ident">split_whitespace</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;A&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;few&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;words&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">iter</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20iter%20%3D%20%22A%20few%20words%22.split_whitespace()%3B%0A%0Aassert_eq!(Some(%22A%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22few%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22words%22)%2C%20iter.next())%3B%0A%0Aassert_eq!(None%2C%20iter.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>All kinds of whitespace are considered:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="string">&quot; Mary   had\ta\u{2009}little  \n\t lamb&quot;</span>.<span class="ident">split_whitespace</span>();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;Mary&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;had&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;a&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;little&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;lamb&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">iter</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20iter%20%3D%20%22%20Mary%20%20%20had%5Cta%5Cu%7B2009%7Dlittle%20%20%5Cn%5Ct%20lamb%22.split_whitespace()%3B%0Aassert_eq!(Some(%22Mary%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22had%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22a%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22little%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22lamb%22)%2C%20iter.next())%3B%0A%0Aassert_eq!(None%2C%20iter.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_ascii_whitespace" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#951-955">source</a></span><a href="#method.split_ascii_whitespace" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_ascii_whitespace" class="fnname">split_ascii_whitespace</a>(&amp;self) -&gt; <a class="struct" href="str/struct.SplitAsciiWhitespace.html" title="struct core::str::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.SplitAsciiWhitespace.html" title="struct core::str::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'a&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.SplitAsciiWhitespace.html" title="struct core::str::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Splits a string slice by ASCII whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of ASCII whitespace.</p>
<p>To split by Unicode <code>Whitespace</code> instead, use <a href="primitive.str.html#method.split_whitespace"><code>split_whitespace</code></a>.</p>
<h5 id="examples-20"><a href="#examples-20">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="string">&quot;A few words&quot;</span>.<span class="ident">split_ascii_whitespace</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;A&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;few&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;words&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">iter</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20iter%20%3D%20%22A%20few%20words%22.split_ascii_whitespace()%3B%0A%0Aassert_eq!(Some(%22A%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22few%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22words%22)%2C%20iter.next())%3B%0A%0Aassert_eq!(None%2C%20iter.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>All kinds of ASCII whitespace are considered:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="string">&quot; Mary   had\ta little  \n\t lamb&quot;</span>.<span class="ident">split_ascii_whitespace</span>();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;Mary&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;had&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;a&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;little&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;lamb&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">iter</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20iter%20%3D%20%22%20Mary%20%20%20had%5Cta%20little%20%20%5Cn%5Ct%20lamb%22.split_ascii_whitespace()%3B%0Aassert_eq!(Some(%22Mary%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22had%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22a%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22little%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22lamb%22)%2C%20iter.next())%3B%0A%0Aassert_eq!(None%2C%20iter.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lines" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#997-999">source</a></span><a href="#method.lines" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.lines" class="fnname">lines</a>(&amp;self) -&gt; <a class="struct" href="str/struct.Lines.html" title="struct core::str::Lines">Lines</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.Lines.html" title="struct core::str::Lines">Lines</a>&lt;'a&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.Lines.html" title="struct core::str::Lines">Lines</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>An iterator over the lines of a string, as string slices.</p>
<p>Lines are ended with either a newline (<code>\n</code>) or a carriage return with
a line feed (<code>\r\n</code>).</p>
<p>The final line ending is optional. A string that ends with a final line
ending will return the same lines as an otherwise identical string
without a final line ending.</p>
<h5 id="examples-21"><a href="#examples-21">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;foo\r\nbar\n\nbaz\n&quot;</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">lines</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">lines</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;baz&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">lines</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20text%20%3D%20%22foo%5Cr%5Cnbar%5Cn%5Cnbaz%5Cn%22%3B%0Alet%20mut%20lines%20%3D%20text.lines()%3B%0A%0Aassert_eq!(Some(%22foo%22)%2C%20lines.next())%3B%0Aassert_eq!(Some(%22bar%22)%2C%20lines.next())%3B%0Aassert_eq!(Some(%22%22)%2C%20lines.next())%3B%0Aassert_eq!(Some(%22baz%22)%2C%20lines.next())%3B%0A%0Aassert_eq!(None%2C%20lines.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>The final line ending isnâ€™t required:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;foo\nbar\n\r\nbaz&quot;</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">lines</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">lines</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;baz&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">lines</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20text%20%3D%20%22foo%5Cnbar%5Cn%5Cr%5Cnbaz%22%3B%0Alet%20mut%20lines%20%3D%20text.lines()%3B%0A%0Aassert_eq!(Some(%22foo%22)%2C%20lines.next())%3B%0Aassert_eq!(Some(%22bar%22)%2C%20lines.next())%3B%0Aassert_eq!(Some(%22%22)%2C%20lines.next())%3B%0Aassert_eq!(Some(%22baz%22)%2C%20lines.next())%3B%0A%0Aassert_eq!(None%2C%20lines.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lines_any" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1006-1008">source</a></span><a href="#method.lines_any" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.lines_any" class="fnname">lines_any</a>(&amp;self) -&gt; <a class="struct" href="str/struct.LinesAny.html" title="struct core::str::LinesAny">LinesAny</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.LinesAny.html" title="struct core::str::LinesAny">LinesAny</a>&lt;'a&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.LinesAny.html" title="struct core::str::LinesAny">LinesAny</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></span></span></span></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.4.0: <p>use lines() instead now</p>
</div></span></summary><div class="docblock"><p>An iterator over the lines of a string.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.encode_utf16" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1027-1029">source</a></span><a href="#method.encode_utf16" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.encode_utf16" class="fnname">encode_utf16</a>(&amp;self) -&gt; <a class="struct" href="str/struct.EncodeUtf16.html" title="struct core::str::EncodeUtf16">EncodeUtf16</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.EncodeUtf16.html" title="struct core::str::EncodeUtf16">EncodeUtf16</a>&lt;'a&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.EncodeUtf16.html" title="struct core::str::EncodeUtf16">EncodeUtf16</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.u16.html">u16</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator of <code>u16</code> over the string encoded as UTF-16.</p>
<h5 id="examples-22"><a href="#examples-22">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;ZaÅ¼Ã³Å‚Ä‡ gÄ™Å›lÄ… jaÅºÅ„&quot;</span>;

<span class="kw">let</span> <span class="ident">utf8_len</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">len</span>();
<span class="kw">let</span> <span class="ident">utf16_len</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">encode_utf16</span>().<span class="ident">count</span>();

<span class="macro">assert!</span>(<span class="ident">utf16_len</span> <span class="op">&lt;</span><span class="op">=</span> <span class="ident">utf8_len</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20text%20%3D%20%22Za%C5%BC%C3%B3%C5%82%C4%87%20g%C4%99%C5%9Bl%C4%85%20ja%C5%BA%C5%84%22%3B%0A%0Alet%20utf8_len%20%3D%20text.len()%3B%0Alet%20utf16_len%20%3D%20text.encode_utf16().count()%3B%0A%0Aassert!(utf16_len%20%3C%3D%20utf8_len)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.contains" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1054-1056">source</a></span><a href="#method.contains" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.contains" class="fnname">contains</a>&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a sub-slice of
this string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-23"><a href="#examples-23">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">bananas</span> <span class="op">=</span> <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert!</span>(<span class="ident">bananas</span>.<span class="ident">contains</span>(<span class="string">&quot;nana&quot;</span>));
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bananas</span>.<span class="ident">contains</span>(<span class="string">&quot;apples&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20bananas%20%3D%20%22bananas%22%3B%0A%0Aassert!(bananas.contains(%22nana%22))%3B%0Aassert!(!bananas.contains(%22apples%22))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.starts_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1080-1082">source</a></span><a href="#method.starts_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.starts_with" class="fnname">starts_with</a>&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a prefix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-24"><a href="#examples-24">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">bananas</span> <span class="op">=</span> <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert!</span>(<span class="ident">bananas</span>.<span class="ident">starts_with</span>(<span class="string">&quot;bana&quot;</span>));
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bananas</span>.<span class="ident">starts_with</span>(<span class="string">&quot;nana&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20bananas%20%3D%20%22bananas%22%3B%0A%0Aassert!(bananas.starts_with(%22bana%22))%3B%0Aassert!(!bananas.starts_with(%22nana%22))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ends_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1106-1111">source</a></span><a href="#method.ends_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.ends_with" class="fnname">ends_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a, Searcher:&nbsp;<a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a suffix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-25"><a href="#examples-25">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">bananas</span> <span class="op">=</span> <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert!</span>(<span class="ident">bananas</span>.<span class="ident">ends_with</span>(<span class="string">&quot;anas&quot;</span>));
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bananas</span>.<span class="ident">ends_with</span>(<span class="string">&quot;nana&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20bananas%20%3D%20%22bananas%22%3B%0A%0Aassert!(bananas.ends_with(%22anas%22))%3B%0Aassert!(!bananas.ends_with(%22nana%22))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.find" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1157-1159">source</a></span><a href="#method.find" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.find" class="fnname">find</a>&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the byte index of the first character of this string slice that
matches the pattern.</p>
<p>Returns <a href="option/enum.Option.html#variant.None" title="None"><code>None</code></a> if the pattern doesnâ€™t match.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-26"><a href="#examples-26">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard Gepardi&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&#39;L&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">0</span>));
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&#39;Ã©&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&quot;pard&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">17</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%20Gepardi%22%3B%0A%0Aassert_eq!(s.find('L')%2C%20Some(0))%3B%0Aassert_eq!(s.find('%C3%A9')%2C%20Some(14))%3B%0Aassert_eq!(s.find(%22pard%22)%2C%20Some(17))%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>More complex patterns using point-free style and closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="ident">char::is_whitespace</span>), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="ident">char::is_lowercase</span>), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="op">|</span><span class="ident">c</span>: <span class="ident">char</span><span class="op">|</span> <span class="ident">c</span>.<span class="ident">is_whitespace</span>() <span class="op">|</span><span class="op">|</span> <span class="ident">c</span>.<span class="ident">is_lowercase</span>()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="op">|</span><span class="ident">c</span>: <span class="ident">char</span><span class="op">|</span> (<span class="ident">c</span> <span class="op">&lt;</span> <span class="string">&#39;o&#39;</span>) <span class="op">&amp;&amp;</span> (<span class="ident">c</span> <span class="op">&gt;</span> <span class="string">&#39;a&#39;</span>)), <span class="prelude-val">Some</span>(<span class="number">4</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%22%3B%0A%0Aassert_eq!(s.find(char%3A%3Ais_whitespace)%2C%20Some(5))%3B%0Aassert_eq!(s.find(char%3A%3Ais_lowercase)%2C%20Some(1))%3B%0Aassert_eq!(s.find(%7Cc%3A%20char%7C%20c.is_whitespace()%20%7C%7C%20c.is_lowercase())%2C%20Some(1))%3B%0Aassert_eq!(s.find(%7Cc%3A%20char%7C%20(c%20%3C%20'o')%20%26%26%20(c%20%3E%20'a'))%2C%20Some(4))%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;
<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];

<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="ident">x</span>), <span class="prelude-val">None</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%22%3B%0Alet%20x%3A%20%26%5B_%5D%20%3D%20%26%5B'1'%2C%20'2'%5D%3B%0A%0Aassert_eq!(s.find(x)%2C%20None)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rfind" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1203-1208">source</a></span><a href="#method.rfind" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rfind" class="fnname">rfind</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a, Searcher:&nbsp;<a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns the byte index for the first character of the rightmost match of the pattern in
this string slice.</p>
<p>Returns <a href="option/enum.Option.html#variant.None" title="None"><code>None</code></a> if the pattern doesnâ€™t match.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-27"><a href="#examples-27">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard Gepardi&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="string">&#39;L&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">13</span>));
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="string">&#39;Ã©&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="string">&quot;pard&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">24</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%20Gepardi%22%3B%0A%0Aassert_eq!(s.rfind('L')%2C%20Some(13))%3B%0Aassert_eq!(s.rfind('%C3%A9')%2C%20Some(14))%3B%0Aassert_eq!(s.rfind(%22pard%22)%2C%20Some(24))%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>More complex patterns with closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="ident">char::is_whitespace</span>), <span class="prelude-val">Some</span>(<span class="number">12</span>));
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="ident">char::is_lowercase</span>), <span class="prelude-val">Some</span>(<span class="number">20</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%22%3B%0A%0Aassert_eq!(s.rfind(char%3A%3Ais_whitespace)%2C%20Some(12))%3B%0Aassert_eq!(s.rfind(char%3A%3Ais_lowercase)%2C%20Some(20))%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;
<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];

<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="ident">x</span>), <span class="prelude-val">None</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%22%3B%0Alet%20x%3A%20%26%5B_%5D%20%3D%20%26%5B'1'%2C%20'2'%5D%3B%0A%0Aassert_eq!(s.rfind(x)%2C%20None)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1325-1333">source</a></span><a href="#method.split" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split" class="fnname">split</a>&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.Split.html" title="struct core::str::Split">Split</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.Split.html" title="struct core::str::Split">Split</a>&lt;'a, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.Split.html" title="struct core::str::Split">Split</a>&lt;'a, P&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>An iterator over substrings of this string slice, separated by
characters matched by a pattern.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior"><a href="#iterator-behavior">Iterator behavior</a></h5>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="primitive.char.html"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="primitive.str.html#method.rsplit"><code>rsplit</code></a> method can be used.</p>
<h5 id="examples-28"><a href="#examples-28">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb&quot;</span>.<span class="ident">split</span>(<span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;lamb&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>.<span class="ident">split</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">split</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lion::tiger::leopard&quot;</span>.<span class="ident">split</span>(<span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1def2ghi&quot;</span>.<span class="ident">split</span>(<span class="ident">char::is_numeric</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXtigerXleopard&quot;</span>.<span class="ident">split</span>(<span class="ident">char::is_uppercase</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22Mary%20had%20a%20little%20lamb%22.split('%20').collect()%3B%0Aassert_eq!(v%2C%20%5B%22Mary%22%2C%20%22had%22%2C%20%22a%22%2C%20%22little%22%2C%20%22lamb%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22%22.split('X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22lionXXtigerXleopard%22.split('X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22lion%22%2C%20%22%22%2C%20%22tiger%22%2C%20%22leopard%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22lion%3A%3Atiger%3A%3Aleopard%22.split(%22%3A%3A%22).collect()%3B%0Aassert_eq!(v%2C%20%5B%22lion%22%2C%20%22tiger%22%2C%20%22leopard%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22abc1def2ghi%22.split(char%3A%3Ais_numeric).collect()%3B%0Aassert_eq!(v%2C%20%5B%22abc%22%2C%20%22def%22%2C%20%22ghi%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22lionXtigerXleopard%22.split(char%3A%3Ais_uppercase).collect()%3B%0Aassert_eq!(v%2C%20%5B%22lion%22%2C%20%22tiger%22%2C%20%22leopard%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>If the pattern is a slice of chars, split on each occurrence of any of the characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;2020-11-03 23:59&quot;</span>.<span class="ident">split</span>(<span class="kw-2">&amp;</span>[<span class="string">&#39;-&#39;</span>, <span class="string">&#39; &#39;</span>, <span class="string">&#39;:&#39;</span>, <span class="string">&#39;@&#39;</span>][..]).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;2020&quot;</span>, <span class="string">&quot;11&quot;</span>, <span class="string">&quot;03&quot;</span>, <span class="string">&quot;23&quot;</span>, <span class="string">&quot;59&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%222020-11-03%2023%3A59%22.split(%26%5B'-'%2C%20'%20'%2C%20'%3A'%2C%20'%40'%5D%5B..%5D).collect()%3B%0Aassert_eq!(v%2C%20%5B%222020%22%2C%20%2211%22%2C%20%2203%22%2C%20%2223%22%2C%20%2259%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">|</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22abc1defXghi%22.split(%7Cc%7C%20c%20%3D%3D%20'1'%20%7C%7C%20c%20%3D%3D%20'X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22abc%22%2C%20%22def%22%2C%20%22ghi%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings in the output:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="string">&quot;||||a||b|c&quot;</span>.<span class="ident">to_string</span>();
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&#39;|&#39;</span>).<span class="ident">collect</span>();

<span class="macro">assert_eq!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20x%20%3D%20%22%7C%7C%7C%7Ca%7C%7Cb%7Cc%22.to_string()%3B%0Alet%20d%3A%20Vec%3C_%3E%20%3D%20x.split('%7C').collect()%3B%0A%0Aassert_eq!(d%2C%20%26%5B%22%22%2C%20%22%22%2C%20%22%22%2C%20%22%22%2C%20%22a%22%2C%20%22%22%2C%20%22b%22%2C%20%22c%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Contiguous separators are separated by the empty string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="string">&quot;(///)&quot;</span>.<span class="ident">to_string</span>();
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&#39;/&#39;</span>).<span class="ident">collect</span>();

<span class="macro">assert_eq!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;(&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;)&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20x%20%3D%20%22(%2F%2F%2F)%22.to_string()%3B%0Alet%20d%3A%20Vec%3C_%3E%20%3D%20x.split('%2F').collect()%3B%0A%0Aassert_eq!(d%2C%20%26%5B%22(%22%2C%20%22%22%2C%20%22%22%2C%20%22)%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Separators at the start or end of a string are neighbored
by empty strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;010&quot;</span>.<span class="ident">split</span>(<span class="string">&quot;0&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20d%3A%20Vec%3C_%3E%20%3D%20%22010%22.split(%220%22).collect()%3B%0Aassert_eq!(d%2C%20%26%5B%22%22%2C%20%221%22%2C%20%22%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>When the empty string is used as a separator, it separates
every character in the string, along with the beginning
and end of the string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">f</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;rust&quot;</span>.<span class="ident">split</span>(<span class="string">&quot;&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">f</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20f%3A%20Vec%3C_%3E%20%3D%20%22rust%22.split(%22%22).collect()%3B%0Aassert_eq!(f%2C%20%26%5B%22%22%2C%20%22r%22%2C%20%22u%22%2C%20%22s%22%2C%20%22t%22%2C%20%22%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Contiguous separators can lead to possibly surprising behavior
when whitespace is used as the separator. This code is correct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="string">&quot;    a  b c&quot;</span>.<span class="ident">to_string</span>();
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();

<span class="macro">assert_eq!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20x%20%3D%20%22%20%20%20%20a%20%20b%20c%22.to_string()%3B%0Alet%20d%3A%20Vec%3C_%3E%20%3D%20x.split('%20').collect()%3B%0A%0Aassert_eq!(d%2C%20%26%5B%22%22%2C%20%22%22%2C%20%22%22%2C%20%22%22%2C%20%22a%22%2C%20%22%22%2C%20%22b%22%2C%20%22c%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>It does <em>not</em> give you:</p>

<div class='information'><div class='tooltip ignore'>â“˜</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="macro">assert_eq!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(d%2C%20%26%5B%22a%22%2C%20%22b%22%2C%20%22c%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Use <a href="primitive.str.html#method.split_whitespace"><code>split_whitespace</code></a> for this behavior.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_inclusive" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1365-1373">source</a></span><a href="#method.split_inclusive" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_inclusive" class="fnname">split_inclusive</a>&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;pat: P<br>) -&gt; <a class="struct" href="str/struct.SplitInclusive.html" title="struct core::str::SplitInclusive">SplitInclusive</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.SplitInclusive.html" title="struct core::str::SplitInclusive">SplitInclusive</a>&lt;'a, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.SplitInclusive.html" title="struct core::str::SplitInclusive">SplitInclusive</a>&lt;'a, P&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>An iterator over substrings of this string slice, separated by
characters matched by a pattern. Differs from the iterator produced by
<code>split</code> in that <code>split_inclusive</code> leaves the matched part as the
terminator of the substring.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-29"><a href="#examples-29">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb\nlittle lamb\nlittle lamb.&quot;</span>
    .<span class="ident">split_inclusive</span>(<span class="string">&#39;\n&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;Mary had a little lamb\n&quot;</span>, <span class="string">&quot;little lamb\n&quot;</span>, <span class="string">&quot;little lamb.&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22Mary%20had%20a%20little%20lamb%5Cnlittle%20lamb%5Cnlittle%20lamb.%22%0A%20%20%20%20.split_inclusive('%5Cn').collect()%3B%0Aassert_eq!(v%2C%20%5B%22Mary%20had%20a%20little%20lamb%5Cn%22%2C%20%22little%20lamb%5Cn%22%2C%20%22little%20lamb.%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>If the last element of the string is matched,
that element will be considered the terminator of the preceding substring.
That substring will be the last item returned by the iterator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb\nlittle lamb\nlittle lamb.\n&quot;</span>
    .<span class="ident">split_inclusive</span>(<span class="string">&#39;\n&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;Mary had a little lamb\n&quot;</span>, <span class="string">&quot;little lamb\n&quot;</span>, <span class="string">&quot;little lamb.\n&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22Mary%20had%20a%20little%20lamb%5Cnlittle%20lamb%5Cnlittle%20lamb.%5Cn%22%0A%20%20%20%20.split_inclusive('%5Cn').collect()%3B%0Aassert_eq!(v%2C%20%5B%22Mary%20had%20a%20little%20lamb%5Cn%22%2C%20%22little%20lamb%5Cn%22%2C%20%22little%20lamb.%5Cn%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplit" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1420-1425">source</a></span><a href="#method.rsplit" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rsplit" class="fnname">rsplit</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.RSplit.html" title="struct core::str::RSplit">RSplit</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.RSplit.html" title="struct core::str::RSplit">RSplit</a>&lt;'a, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.RSplit.html" title="struct core::str::RSplit">RSplit</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a, Searcher:&nbsp;<a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a, Searcher:&nbsp;<a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of the given string slice, separated by
characters matched by a pattern and yielded in reverse order.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-1"><a href="#iterator-behavior-1">Iterator behavior</a></h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="primitive.str.html#method.split"><code>split</code></a> method can be used.</p>
<h5 id="examples-30"><a href="#examples-30">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;lamb&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;Mary&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;lion&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lion::tiger::leopard&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;lion&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22Mary%20had%20a%20little%20lamb%22.rsplit('%20').collect()%3B%0Aassert_eq!(v%2C%20%5B%22lamb%22%2C%20%22little%22%2C%20%22a%22%2C%20%22had%22%2C%20%22Mary%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22%22.rsplit('X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22lionXXtigerXleopard%22.rsplit('X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22leopard%22%2C%20%22tiger%22%2C%20%22%22%2C%20%22lion%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22lion%3A%3Atiger%3A%3Aleopard%22.rsplit(%22%3A%3A%22).collect()%3B%0Aassert_eq!(v%2C%20%5B%22leopard%22%2C%20%22tiger%22%2C%20%22lion%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">rsplit</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">|</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;abc&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22abc1defXghi%22.rsplit(%7Cc%7C%20c%20%3D%3D%20'1'%20%7C%7C%20c%20%3D%3D%20'X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22ghi%22%2C%20%22def%22%2C%20%22abc%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_terminator" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1471-1473">source</a></span><a href="#method.split_terminator" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_terminator" class="fnname">split_terminator</a>&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;pat: P<br>) -&gt; <a class="struct" href="str/struct.SplitTerminator.html" title="struct core::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.SplitTerminator.html" title="struct core::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.SplitTerminator.html" title="struct core::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>An iterator over substrings of the given string slice, separated by
characters matched by a pattern.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>Equivalent to <a href="primitive.str.html#method.split"><code>split</code></a>, except that the trailing substring
is skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h5 id="iterator-behavior-2"><a href="#iterator-behavior-2">Iterator behavior</a></h5>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="primitive.char.html"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="primitive.str.html#method.rsplit_terminator"><code>rsplit_terminator</code></a> method can be used.</p>
<h5 id="examples-31"><a href="#examples-31">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A.B.&quot;</span>.<span class="ident">split_terminator</span>(<span class="string">&#39;.&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A..B..&quot;</span>.<span class="ident">split_terminator</span>(<span class="string">&quot;.&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A.B:C.D&quot;</span>.<span class="ident">split_terminator</span>(<span class="kw-2">&amp;</span>[<span class="string">&#39;.&#39;</span>, <span class="string">&#39;:&#39;</span>][..]).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22A.B.%22.split_terminator('.').collect()%3B%0Aassert_eq!(v%2C%20%5B%22A%22%2C%20%22B%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22A..B..%22.split_terminator(%22.%22).collect()%3B%0Aassert_eq!(v%2C%20%5B%22A%22%2C%20%22%22%2C%20%22B%22%2C%20%22%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22A.B%3AC.D%22.split_terminator(%26%5B'.'%2C%20'%3A'%5D%5B..%5D).collect()%3B%0Aassert_eq!(v%2C%20%5B%22A%22%2C%20%22B%22%2C%20%22C%22%2C%20%22D%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplit_terminator" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1517-1522">source</a></span><a href="#method.rsplit_terminator" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rsplit_terminator" class="fnname">rsplit_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.RSplitTerminator.html" title="struct core::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.RSplitTerminator.html" title="struct core::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.RSplitTerminator.html" title="struct core::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a, Searcher:&nbsp;<a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a, Searcher:&nbsp;<a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of <code>self</code>, separated by characters
matched by a pattern and yielded in reverse order.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>Equivalent to <a href="primitive.str.html#method.split"><code>split</code></a>, except that the trailing substring is
skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h5 id="iterator-behavior-3"><a href="#iterator-behavior-3">Iterator behavior</a></h5>
<p>The returned iterator requires that the pattern supports a
reverse search, and it will be double ended if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="primitive.str.html#method.split_terminator"><code>split_terminator</code></a> method can be
used.</p>
<h5 id="examples-32"><a href="#examples-32">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A.B.&quot;</span>.<span class="ident">rsplit_terminator</span>(<span class="string">&#39;.&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A..B..&quot;</span>.<span class="ident">rsplit_terminator</span>(<span class="string">&quot;.&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;A&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A.B:C.D&quot;</span>.<span class="ident">rsplit_terminator</span>(<span class="kw-2">&amp;</span>[<span class="string">&#39;.&#39;</span>, <span class="string">&#39;:&#39;</span>][..]).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;D&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22A.B.%22.rsplit_terminator('.').collect()%3B%0Aassert_eq!(v%2C%20%5B%22B%22%2C%20%22A%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22A..B..%22.rsplit_terminator(%22.%22).collect()%3B%0Aassert_eq!(v%2C%20%5B%22%22%2C%20%22B%22%2C%20%22%22%2C%20%22A%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22A.B%3AC.D%22.rsplit_terminator(%26%5B'.'%2C%20'%3A'%5D%5B..%5D).collect()%3B%0Aassert_eq!(v%2C%20%5B%22D%22%2C%20%22C%22%2C%20%22B%22%2C%20%22A%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.splitn" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1572-1574">source</a></span><a href="#method.splitn" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.splitn" class="fnname">splitn</a>&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;(&amp;'a self, n: <a class="primitive" href="primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="str/struct.SplitN.html" title="struct core::str::SplitN">SplitN</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.SplitN.html" title="struct core::str::SplitN">SplitN</a>&lt;'a, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.SplitN.html" title="struct core::str::SplitN">SplitN</a>&lt;'a, P&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>An iterator over substrings of the given string slice, separated by a
pattern, restricted to returning at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-4"><a href="#iterator-behavior-4">Iterator behavior</a></h5>
<p>The returned iterator will not be double ended, because it is
not efficient to support.</p>
<p>If the pattern allows a reverse search, the <a href="primitive.str.html#method.rsplitn"><code>rsplitn</code></a> method can be
used.</p>
<h5 id="examples-33"><a href="#examples-33">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lambda&quot;</span>.<span class="ident">splitn</span>(<span class="number">3</span>, <span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;a little lambda&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">splitn</span>(<span class="number">3</span>, <span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tigerXleopard&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXdef&quot;</span>.<span class="ident">splitn</span>(<span class="number">1</span>, <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;abcXdef&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>.<span class="ident">splitn</span>(<span class="number">1</span>, <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22Mary%20had%20a%20little%20lambda%22.splitn(3%2C%20'%20').collect()%3B%0Aassert_eq!(v%2C%20%5B%22Mary%22%2C%20%22had%22%2C%20%22a%20little%20lambda%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22lionXXtigerXleopard%22.splitn(3%2C%20%22X%22).collect()%3B%0Aassert_eq!(v%2C%20%5B%22lion%22%2C%20%22%22%2C%20%22tigerXleopard%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22abcXdef%22.splitn(1%2C%20'X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22abcXdef%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22%22.splitn(1%2C%20'X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">splitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">|</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;defXghi&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22abc1defXghi%22.splitn(2%2C%20%7Cc%7C%20c%20%3D%3D%20'1'%20%7C%7C%20c%20%3D%3D%20'X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22abc%22%2C%20%22defXghi%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplitn" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1621-1626">source</a></span><a href="#method.rsplitn" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rsplitn" class="fnname">rsplitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="str/struct.RSplitN.html" title="struct core::str::RSplitN">RSplitN</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.RSplitN.html" title="struct core::str::RSplitN">RSplitN</a>&lt;'a, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.RSplitN.html" title="struct core::str::RSplitN">RSplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a, Searcher:&nbsp;<a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a, Searcher:&nbsp;<a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of this string slice, separated by a
pattern, starting from the end of the string, restricted to returning
at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-5"><a href="#iterator-behavior-5">Iterator behavior</a></h5>
<p>The returned iterator will not be double ended, because it is not
efficient to support.</p>
<p>For splitting from the front, the <a href="primitive.str.html#method.splitn"><code>splitn</code></a> method can be used.</p>
<h5 id="examples-34"><a href="#examples-34">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">3</span>, <span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;lamb&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;Mary had a&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">3</span>, <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;lionX&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lion::tiger::leopard&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">2</span>, <span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;lion::tiger&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22Mary%20had%20a%20little%20lamb%22.rsplitn(3%2C%20'%20').collect()%3B%0Aassert_eq!(v%2C%20%5B%22lamb%22%2C%20%22little%22%2C%20%22Mary%20had%20a%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22lionXXtigerXleopard%22.rsplitn(3%2C%20'X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22leopard%22%2C%20%22tiger%22%2C%20%22lionX%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22lion%3A%3Atiger%3A%3Aleopard%22.rsplitn(2%2C%20%22%3A%3A%22).collect()%3B%0Aassert_eq!(v%2C%20%5B%22leopard%22%2C%20%22lion%3A%3Atiger%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">|</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;abc1def&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22abc1defXghi%22.rsplitn(2%2C%20%7Cc%7C%20c%20%3D%3D%20'1'%20%7C%7C%20c%20%3D%3D%20'X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22ghi%22%2C%20%22abc1def%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_once" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1640-1644">source</a></span><a href="#method.split_once" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_once" class="fnname">split_once</a>&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;delimiter: P<br>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.tuple.html">(</a>&amp;'a <a class="primitive" href="primitive.str.html">str</a>, &amp;'a <a class="primitive" href="primitive.str.html">str</a><a class="primitive" href="primitive.tuple.html">)</a>&gt;</h4></section></summary><div class="docblock"><p>Splits the string on the first occurrence of the specified delimiter and
returns prefix before delimiter and suffix after delimiter.</p>
<h5 id="examples-35"><a href="#examples-35">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;cfg&quot;</span>.<span class="ident">split_once</span>(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=foo&quot;</span>.<span class="ident">split_once</span>(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg&quot;</span>, <span class="string">&quot;foo&quot;</span>)));
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=foo=bar&quot;</span>.<span class="ident">split_once</span>(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg&quot;</span>, <span class="string">&quot;foo=bar&quot;</span>)));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22cfg%22.split_once('%3D')%2C%20None)%3B%0Aassert_eq!(%22cfg%3Dfoo%22.split_once('%3D')%2C%20Some((%22cfg%22%2C%20%22foo%22)))%3B%0Aassert_eq!(%22cfg%3Dfoo%3Dbar%22.split_once('%3D')%2C%20Some((%22cfg%22%2C%20%22foo%3Dbar%22)))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplit_once" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1658-1665">source</a></span><a href="#method.rsplit_once" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rsplit_once" class="fnname">rsplit_once</a>&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.tuple.html">(</a>&amp;'a <a class="primitive" href="primitive.str.html">str</a>, &amp;'a <a class="primitive" href="primitive.str.html">str</a><a class="primitive" href="primitive.tuple.html">)</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a, Searcher:&nbsp;<a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Splits the string on the last occurrence of the specified delimiter and
returns prefix before delimiter and suffix after delimiter.</p>
<h5 id="examples-36"><a href="#examples-36">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;cfg&quot;</span>.<span class="ident">rsplit_once</span>(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=foo&quot;</span>.<span class="ident">rsplit_once</span>(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg&quot;</span>, <span class="string">&quot;foo&quot;</span>)));
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=foo=bar&quot;</span>.<span class="ident">rsplit_once</span>(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg=foo&quot;</span>, <span class="string">&quot;bar&quot;</span>)));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22cfg%22.rsplit_once('%3D')%2C%20None)%3B%0Aassert_eq!(%22cfg%3Dfoo%22.rsplit_once('%3D')%2C%20Some((%22cfg%22%2C%20%22foo%22)))%3B%0Aassert_eq!(%22cfg%3Dfoo%3Dbar%22.rsplit_once('%3D')%2C%20Some((%22cfg%3Dfoo%22%2C%20%22bar%22)))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.matches" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1700-1702">source</a></span><a href="#method.matches" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.matches" class="fnname">matches</a>&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.Matches.html" title="struct core::str::Matches">Matches</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.Matches.html" title="struct core::str::Matches">Matches</a>&lt;'a, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.Matches.html" title="struct core::str::Matches">Matches</a>&lt;'a, P&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within the given string
slice.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-6"><a href="#iterator-behavior-6">Iterator behavior</a></h5>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="primitive.char.html"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="primitive.str.html#method.matches"><code>rmatches</code></a> method can be used.</p>
<h5 id="examples-37"><a href="#examples-37">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">matches</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abc2abc3&quot;</span>.<span class="ident">matches</span>(<span class="ident">char::is_numeric</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22abcXXXabcYYYabc%22.matches(%22abc%22).collect()%3B%0Aassert_eq!(v%2C%20%5B%22abc%22%2C%20%22abc%22%2C%20%22abc%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%221abc2abc3%22.matches(char%3A%3Ais_numeric).collect()%3B%0Aassert_eq!(v%2C%20%5B%221%22%2C%20%222%22%2C%20%223%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rmatches" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1736-1741">source</a></span><a href="#method.rmatches" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rmatches" class="fnname">rmatches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.RMatches.html" title="struct core::str::RMatches">RMatches</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.RMatches.html" title="struct core::str::RMatches">RMatches</a>&lt;'a, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.RMatches.html" title="struct core::str::RMatches">RMatches</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a, Searcher:&nbsp;<a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a, Searcher:&nbsp;<a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within this string slice,
yielded in reverse order.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-7"><a href="#iterator-behavior-7">Iterator behavior</a></h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="primitive.str.html#method.matches"><code>matches</code></a> method can be used.</p>
<h5 id="examples-38"><a href="#examples-38">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">rmatches</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abc2abc3&quot;</span>.<span class="ident">rmatches</span>(<span class="ident">char::is_numeric</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;3&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;1&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22abcXXXabcYYYabc%22.rmatches(%22abc%22).collect()%3B%0Aassert_eq!(v%2C%20%5B%22abc%22%2C%20%22abc%22%2C%20%22abc%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%221abc2abc3%22.rmatches(char%3A%3Ais_numeric).collect()%3B%0Aassert_eq!(v%2C%20%5B%223%22%2C%20%222%22%2C%20%221%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.match_indices" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1782-1784">source</a></span><a href="#method.match_indices" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.match_indices" class="fnname">match_indices</a>&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;pat: P<br>) -&gt; <a class="struct" href="str/struct.MatchIndices.html" title="struct core::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.MatchIndices.html" title="struct core::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.MatchIndices.html" title="struct core::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.tuple.html">(</a><a class="primitive" href="primitive.usize.html">usize</a>, &amp;'a <a class="primitive" href="primitive.str.html">str</a><a class="primitive" href="primitive.tuple.html">)</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within this string
slice as well as the index that the match starts at.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the first match are returned.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-8"><a href="#iterator-behavior-8">Iterator behavior</a></h5>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="primitive.char.html"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="primitive.str.html#method.rmatch_indices"><code>rmatch_indices</code></a> method can be used.</p>
<h5 id="examples-39"><a href="#examples-39">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">match_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [(<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">6</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">12</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abcabc2&quot;</span>.<span class="ident">match_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">4</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;ababa&quot;</span>.<span class="ident">match_indices</span>(<span class="string">&quot;aba&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [(<span class="number">0</span>, <span class="string">&quot;aba&quot;</span>)]); <span class="comment">// only the first `aba`</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C_%3E%20%3D%20%22abcXXXabcYYYabc%22.match_indices(%22abc%22).collect()%3B%0Aassert_eq!(v%2C%20%5B(0%2C%20%22abc%22)%2C%20(6%2C%20%22abc%22)%2C%20(12%2C%20%22abc%22)%5D)%3B%0A%0Alet%20v%3A%20Vec%3C_%3E%20%3D%20%221abcabc2%22.match_indices(%22abc%22).collect()%3B%0Aassert_eq!(v%2C%20%5B(1%2C%20%22abc%22)%2C%20(4%2C%20%22abc%22)%5D)%3B%0A%0Alet%20v%3A%20Vec%3C_%3E%20%3D%20%22ababa%22.match_indices(%22aba%22).collect()%3B%0Aassert_eq!(v%2C%20%5B(0%2C%20%22aba%22)%5D)%3B%20%2F%2F%20only%20the%20first%20%60aba%60%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rmatch_indices" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1824-1829">source</a></span><a href="#method.rmatch_indices" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rmatch_indices" class="fnname">rmatch_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.RMatchIndices.html" title="struct core::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.RMatchIndices.html" title="struct core::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.RMatchIndices.html" title="struct core::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a, Searcher:&nbsp;<a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.tuple.html">(</a><a class="primitive" href="primitive.usize.html">usize</a>, &amp;'a <a class="primitive" href="primitive.str.html">str</a><a class="primitive" href="primitive.tuple.html">)</a>;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a, Searcher:&nbsp;<a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within <code>self</code>,
yielded in reverse order along with the index of the match.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the last match are returned.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-9"><a href="#iterator-behavior-9">Iterator behavior</a></h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="primitive.str.html#method.match_indices"><code>match_indices</code></a> method can be used.</p>
<h5 id="examples-40"><a href="#examples-40">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">rmatch_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [(<span class="number">12</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">6</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abcabc2&quot;</span>.<span class="ident">rmatch_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [(<span class="number">4</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;ababa&quot;</span>.<span class="ident">rmatch_indices</span>(<span class="string">&quot;aba&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [(<span class="number">2</span>, <span class="string">&quot;aba&quot;</span>)]); <span class="comment">// only the last `aba`</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C_%3E%20%3D%20%22abcXXXabcYYYabc%22.rmatch_indices(%22abc%22).collect()%3B%0Aassert_eq!(v%2C%20%5B(12%2C%20%22abc%22)%2C%20(6%2C%20%22abc%22)%2C%20(0%2C%20%22abc%22)%5D)%3B%0A%0Alet%20v%3A%20Vec%3C_%3E%20%3D%20%221abcabc2%22.rmatch_indices(%22abc%22).collect()%3B%0Aassert_eq!(v%2C%20%5B(4%2C%20%22abc%22)%2C%20(1%2C%20%22abc%22)%5D)%3B%0A%0Alet%20v%3A%20Vec%3C_%3E%20%3D%20%22ababa%22.rmatch_indices(%22aba%22).collect()%3B%0Aassert_eq!(v%2C%20%5B(2%2C%20%22aba%22)%5D)%3B%20%2F%2F%20only%20the%20last%20%60aba%60%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.trim" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1850-1852">source</a></span><a href="#method.trim" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim" class="fnname">trim</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading and trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="examples-41"><a href="#examples-41">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;\n Hello\tworld\t\n&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;Hello\tworld&quot;</span>, <span class="ident">s</span>.<span class="ident">trim</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%5Cn%20Hello%5Ctworld%5Ct%5Cn%22%3B%0A%0Aassert_eq!(%22Hello%5Ctworld%22%2C%20s.trim())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.trim_start" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1889-1891">source</a></span><a href="#method.trim_start" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_start" class="fnname">trim_start</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="text-directionality"><a href="#text-directionality">Text directionality</a></h5>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
Arabic or Hebrew, this will be the right side.</p>
<h5 id="examples-42"><a href="#examples-42">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;\n Hello\tworld\t\n&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;Hello\tworld\t\n&quot;</span>, <span class="ident">s</span>.<span class="ident">trim_start</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%5Cn%20Hello%5Ctworld%5Ct%5Cn%22%3B%0Aassert_eq!(%22Hello%5Ctworld%5Ct%5Cn%22%2C%20s.trim_start())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  English  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;E&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_start</span>().<span class="ident">chars</span>().<span class="ident">next</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  ×¢×‘×¨×™×ª  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;×¢&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_start</span>().<span class="ident">chars</span>().<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%20%20English%20%20%22%3B%0Aassert!(Some('E')%20%3D%3D%20s.trim_start().chars().next())%3B%0A%0Alet%20s%20%3D%20%22%20%20%D7%A2%D7%91%D7%A8%D7%99%D7%AA%20%20%22%3B%0Aassert!(Some('%D7%A2')%20%3D%3D%20s.trim_start().chars().next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.trim_end" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1928-1930">source</a></span><a href="#method.trim_end" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_end" class="fnname">trim_end</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="text-directionality-1"><a href="#text-directionality-1">Text directionality</a></h5>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
Arabic or Hebrew, this will be the left side.</p>
<h5 id="examples-43"><a href="#examples-43">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;\n Hello\tworld\t\n&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;\n Hello\tworld&quot;</span>, <span class="ident">s</span>.<span class="ident">trim_end</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%5Cn%20Hello%5Ctworld%5Ct%5Cn%22%3B%0Aassert_eq!(%22%5Cn%20Hello%5Ctworld%22%2C%20s.trim_end())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  English  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;h&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_end</span>().<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">next</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  ×¢×‘×¨×™×ª  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;×ª&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_end</span>().<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%20%20English%20%20%22%3B%0Aassert!(Some('h')%20%3D%3D%20s.trim_end().chars().rev().next())%3B%0A%0Alet%20s%20%3D%20%22%20%20%D7%A2%D7%91%D7%A8%D7%99%D7%AA%20%20%22%3B%0Aassert!(Some('%D7%AA')%20%3D%3D%20s.trim_end().chars().rev().next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.trim_left" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1968-1970">source</a></span><a href="#method.trim_left" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_left" class="fnname">trim_left</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.33.0: <p>superseded by <code>trim_start</code></p>
</div></span></summary><div class="docblock"><p>Returns a string slice with leading whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-2"><a href="#text-directionality-2">Text directionality</a></h5>
<p>A string is a sequence of bytes. â€˜Leftâ€™ in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>right</em> side, not the left.</p>
<h5 id="examples-44"><a href="#examples-44">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;Hello\tworld\t&quot;</span>, <span class="ident">s</span>.<span class="ident">trim_left</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%20Hello%5Ctworld%5Ct%22%3B%0A%0Aassert_eq!(%22Hello%5Ctworld%5Ct%22%2C%20s.trim_left())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  English&quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;E&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_left</span>().<span class="ident">chars</span>().<span class="ident">next</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  ×¢×‘×¨×™×ª&quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;×¢&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_left</span>().<span class="ident">chars</span>().<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%20%20English%22%3B%0Aassert!(Some('E')%20%3D%3D%20s.trim_left().chars().next())%3B%0A%0Alet%20s%20%3D%20%22%20%20%D7%A2%D7%91%D7%A8%D7%99%D7%AA%22%3B%0Aassert!(Some('%D7%A2')%20%3D%3D%20s.trim_left().chars().next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.trim_right" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#2008-2010">source</a></span><a href="#method.trim_right" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_right" class="fnname">trim_right</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.33.0: <p>superseded by <code>trim_end</code></p>
</div></span></summary><div class="docblock"><p>Returns a string slice with trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-3"><a href="#text-directionality-3">Text directionality</a></h5>
<p>A string is a sequence of bytes. â€˜Rightâ€™ in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>left</em> side, not the right.</p>
<h5 id="examples-45"><a href="#examples-45">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot; Hello\tworld&quot;</span>, <span class="ident">s</span>.<span class="ident">trim_right</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%20Hello%5Ctworld%5Ct%22%3B%0A%0Aassert_eq!(%22%20Hello%5Ctworld%22%2C%20s.trim_right())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;English  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;h&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_right</span>().<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">next</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;×¢×‘×¨×™×ª  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;×ª&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_right</span>().<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22English%20%20%22%3B%0Aassert!(Some('h')%20%3D%3D%20s.trim_right().chars().rev().next())%3B%0A%0Alet%20s%20%3D%20%22%D7%A2%D7%91%D7%A8%D7%99%D7%AA%20%20%22%3B%0Aassert!(Some('%D7%AA')%20%3D%3D%20s.trim_right().chars().rev().next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.trim_matches" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#2041-2058">source</a></span><a href="#method.trim_matches" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_matches" class="fnname">trim_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a, Searcher:&nbsp;<a class="trait" href="str/pattern/trait.DoubleEndedSearcher.html" title="trait core::str::pattern::DoubleEndedSearcher">DoubleEndedSearcher</a>&lt;'a&gt;&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns a string slice with all prefixes and suffixes that match a
pattern repeatedly removed.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a function
or closure that determines if a character matches.</p>
<h5 id="examples-46"><a href="#examples-46">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_matches</span>(<span class="ident">char::is_numeric</span>), <span class="string">&quot;foo1bar&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_matches</span>(<span class="ident">x</span>), <span class="string">&quot;foo1bar&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%2211foo1bar11%22.trim_matches('1')%2C%20%22foo1bar%22)%3B%0Aassert_eq!(%22123foo1bar123%22.trim_matches(char%3A%3Ais_numeric)%2C%20%22foo1bar%22)%3B%0A%0Alet%20x%3A%20%26%5B_%5D%20%3D%20%26%5B'1'%2C%20'2'%5D%3B%0Aassert_eq!(%2212foo1bar12%22.trim_matches(x)%2C%20%22foo1bar%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;1foo1barXX&quot;</span>.<span class="ident">trim_matches</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">|</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>), <span class="string">&quot;foo1bar&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%221foo1barXX%22.trim_matches(%7Cc%7C%20c%20%3D%3D%20'1'%20%7C%7C%20c%20%3D%3D%20'X')%2C%20%22foo1bar%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.trim_start_matches" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2090-2098">source</a></span><a href="#method.trim_start_matches" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_start_matches" class="fnname">trim_start_matches</a>&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-4"><a href="#text-directionality-4">Text directionality</a></h5>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
Arabic or Hebrew, this will be the right side.</p>
<h5 id="examples-47"><a href="#examples-47">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_start_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar11&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_start_matches</span>(<span class="ident">char::is_numeric</span>), <span class="string">&quot;foo1bar123&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_start_matches</span>(<span class="ident">x</span>), <span class="string">&quot;foo1bar12&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%2211foo1bar11%22.trim_start_matches('1')%2C%20%22foo1bar11%22)%3B%0Aassert_eq!(%22123foo1bar123%22.trim_start_matches(char%3A%3Ais_numeric)%2C%20%22foo1bar123%22)%3B%0A%0Alet%20x%3A%20%26%5B_%5D%20%3D%20%26%5B'1'%2C%20'2'%5D%3B%0Aassert_eq!(%2212foo1bar12%22.trim_start_matches(x)%2C%20%22foo1bar12%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.strip_prefix" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2123-2125">source</a></span><a href="#method.strip_prefix" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.strip_prefix" class="fnname">strip_prefix</a>&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;(&amp;'a self, prefix: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a string slice with the prefix removed.</p>
<p>If the string starts with the pattern <code>prefix</code>, returns substring after the prefix, wrapped
in <code>Some</code>.  Unlike <code>trim_start_matches</code>, this method removes the prefix exactly once.</p>
<p>If the string does not start with <code>prefix</code>, returns <code>None</code>.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-48"><a href="#examples-48">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;foo:bar&quot;</span>.<span class="ident">strip_prefix</span>(<span class="string">&quot;foo:&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;foo:bar&quot;</span>.<span class="ident">strip_prefix</span>(<span class="string">&quot;bar&quot;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;foofoo&quot;</span>.<span class="ident">strip_prefix</span>(<span class="string">&quot;foo&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22foo%3Abar%22.strip_prefix(%22foo%3A%22)%2C%20Some(%22bar%22))%3B%0Aassert_eq!(%22foo%3Abar%22.strip_prefix(%22bar%22)%2C%20None)%3B%0Aassert_eq!(%22foofoo%22.strip_prefix(%22foo%22)%2C%20Some(%22foo%22))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.strip_suffix" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2150-2156">source</a></span><a href="#method.strip_suffix" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.strip_suffix" class="fnname">strip_suffix</a>&lt;'a, P&gt;(&amp;'a self, suffix: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns a string slice with the suffix removed.</p>
<p>If the string ends with the pattern <code>suffix</code>, returns the substring before the suffix,
wrapped in <code>Some</code>.  Unlike <code>trim_end_matches</code>, this method removes the suffix exactly once.</p>
<p>If the string does not end with <code>suffix</code>, returns <code>None</code>.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-49"><a href="#examples-49">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;bar:foo&quot;</span>.<span class="ident">strip_suffix</span>(<span class="string">&quot;:foo&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;bar:foo&quot;</span>.<span class="ident">strip_suffix</span>(<span class="string">&quot;bar&quot;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;foofoo&quot;</span>.<span class="ident">strip_suffix</span>(<span class="string">&quot;foo&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22bar%3Afoo%22.strip_suffix(%22%3Afoo%22)%2C%20Some(%22bar%22))%3B%0Aassert_eq!(%22bar%3Afoo%22.strip_suffix(%22bar%22)%2C%20None)%3B%0Aassert_eq!(%22foofoo%22.strip_suffix(%22foo%22)%2C%20Some(%22foo%22))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.trim_end_matches" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2194-2205">source</a></span><a href="#method.trim_end_matches" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_end_matches" class="fnname">trim_end_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a, Searcher:&nbsp;<a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-5"><a href="#text-directionality-5">Text directionality</a></h5>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
Arabic or Hebrew, this will be the left side.</p>
<h5 id="examples-50"><a href="#examples-50">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_end_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;11foo1bar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_end_matches</span>(<span class="ident">char::is_numeric</span>), <span class="string">&quot;123foo1bar&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_end_matches</span>(<span class="ident">x</span>), <span class="string">&quot;12foo1bar&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%2211foo1bar11%22.trim_end_matches('1')%2C%20%2211foo1bar%22)%3B%0Aassert_eq!(%22123foo1bar123%22.trim_end_matches(char%3A%3Ais_numeric)%2C%20%22123foo1bar%22)%3B%0A%0Alet%20x%3A%20%26%5B_%5D%20%3D%20%26%5B'1'%2C%20'2'%5D%3B%0Aassert_eq!(%2212foo1bar12%22.trim_end_matches(x)%2C%20%2212foo1bar%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;1fooX&quot;</span>.<span class="ident">trim_end_matches</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">|</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>), <span class="string">&quot;1foo&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%221fooX%22.trim_end_matches(%7Cc%7C%20c%20%3D%3D%20'1'%20%7C%7C%20c%20%3D%3D%20'X')%2C%20%221foo%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.trim_left_matches" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#2240-2242">source</a></span><a href="#method.trim_left_matches" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_left_matches" class="fnname">trim_left_matches</a>&lt;'a, P:&nbsp;<a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.33.0: <p>superseded by <code>trim_start_matches</code></p>
</div></span></summary><div class="docblock"><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-6"><a href="#text-directionality-6">Text directionality</a></h5>
<p>A string is a sequence of bytes. â€˜Leftâ€™ in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>right</em> side, not the left.</p>
<h5 id="examples-51"><a href="#examples-51">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_left_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar11&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_left_matches</span>(<span class="ident">char::is_numeric</span>), <span class="string">&quot;foo1bar123&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_left_matches</span>(<span class="ident">x</span>), <span class="string">&quot;foo1bar12&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%2211foo1bar11%22.trim_left_matches('1')%2C%20%22foo1bar11%22)%3B%0Aassert_eq!(%22123foo1bar123%22.trim_left_matches(char%3A%3Ais_numeric)%2C%20%22foo1bar123%22)%3B%0A%0Alet%20x%3A%20%26%5B_%5D%20%3D%20%26%5B'1'%2C%20'2'%5D%3B%0Aassert_eq!(%2212foo1bar12%22.trim_left_matches(x)%2C%20%22foo1bar12%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.trim_right_matches" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#2283-2288">source</a></span><a href="#method.trim_right_matches" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_right_matches" class="fnname">trim_right_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a, Searcher:&nbsp;<a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;&gt;,&nbsp;</span></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.33.0: <p>superseded by <code>trim_end_matches</code></p>
</div></span></summary><div class="docblock"><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-7"><a href="#text-directionality-7">Text directionality</a></h5>
<p>A string is a sequence of bytes. â€˜Rightâ€™ in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>left</em> side, not the right.</p>
<h5 id="examples-52"><a href="#examples-52">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;11foo1bar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="ident">char::is_numeric</span>), <span class="string">&quot;123foo1bar&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="ident">x</span>), <span class="string">&quot;12foo1bar&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%2211foo1bar11%22.trim_right_matches('1')%2C%20%2211foo1bar%22)%3B%0Aassert_eq!(%22123foo1bar123%22.trim_right_matches(char%3A%3Ais_numeric)%2C%20%22123foo1bar%22)%3B%0A%0Alet%20x%3A%20%26%5B_%5D%20%3D%20%26%5B'1'%2C%20'2'%5D%3B%0Aassert_eq!(%2212foo1bar12%22.trim_right_matches(x)%2C%20%2212foo1bar%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;1fooX&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">|</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>), <span class="string">&quot;1foo&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%221fooX%22.trim_right_matches(%7Cc%7C%20c%20%3D%3D%20'1'%20%7C%7C%20c%20%3D%3D%20'X')%2C%20%221foo%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.parse" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#2335-2337">source</a></span><a href="#method.parse" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.parse" class="fnname">parse</a>&lt;F:&nbsp;<a class="trait" href="str/trait.FromStr.html" title="trait core::str::FromStr">FromStr</a>&gt;(&amp;self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;F, F::<a class="associatedtype" href="str/trait.FromStr.html#associatedtype.Err" title="type core::str::FromStr::Err">Err</a>&gt;</h4></section></summary><div class="docblock"><p>Parses this string slice into another type.</p>
<p>Because <code>parse</code> is so general, it can cause problems with type
inference. As such, <code>parse</code> is one of the few times youâ€™ll see
the syntax affectionately known as the â€˜turbofishâ€™: <code>::&lt;&gt;</code>. This
helps the inference algorithm understand specifically which type
youâ€™re trying to parse into.</p>
<p><code>parse</code> can parse into any type that implements the <a href="str/trait.FromStr.html" title="FromStr"><code>FromStr</code></a> trait.</p>
<h5 id="errors"><a href="#errors">Errors</a></h5>
<p>Will return <a href="str/trait.FromStr.html#associatedtype.Err"><code>Err</code></a> if itâ€™s not possible to parse this string slice into
the desired type.</p>
<h5 id="examples-53"><a href="#examples-53">Examples</a></h5>
<p>Basic usage</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">four</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="string">&quot;4&quot;</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>();

<span class="macro">assert_eq!</span>(<span class="number">4</span>, <span class="ident">four</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20four%3A%20u32%20%3D%20%224%22.parse().unwrap()%3B%0A%0Aassert_eq!(4%2C%20four)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Using the â€˜turbofishâ€™ instead of annotating <code>four</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> <span class="string">&quot;4&quot;</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Ok</span>(<span class="number">4</span>), <span class="ident">four</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20four%20%3D%20%224%22.parse%3A%3A%3Cu32%3E()%3B%0A%0Aassert_eq!(Ok(4)%2C%20four)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Failing to parse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">nope</span> <span class="op">=</span> <span class="string">&quot;j&quot;</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>();

<span class="macro">assert!</span>(<span class="ident">nope</span>.<span class="ident">is_err</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20nope%20%3D%20%22j%22.parse%3A%3A%3Cu32%3E()%3B%0A%0Aassert!(nope.is_err())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_ascii" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2353-2358">source</a></span><a href="#method.is_ascii" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.is_ascii" class="fnname">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if all characters in this string are within the ASCII range.</p>
<h5 id="examples-54"><a href="#examples-54">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">ascii</span> <span class="op">=</span> <span class="string">&quot;hello!\n&quot;</span>;
<span class="kw">let</span> <span class="ident">non_ascii</span> <span class="op">=</span> <span class="string">&quot;GrÃ¼ÃŸe, JÃ¼rgen â¤&quot;</span>;

<span class="macro">assert!</span>(<span class="ident">ascii</span>.<span class="ident">is_ascii</span>());
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">non_ascii</span>.<span class="ident">is_ascii</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ascii%20%3D%20%22hello!%5Cn%22%3B%0Alet%20non_ascii%20%3D%20%22Gr%C3%BC%C3%9Fe%2C%20J%C3%BCrgen%20%E2%9D%A4%22%3B%0A%0Aassert!(ascii.is_ascii())%3B%0Aassert!(!non_ascii.is_ascii())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq_ignore_ascii_case" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2375-2377">source</a></span><a href="#method.eq_ignore_ascii_case" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.eq_ignore_ascii_case" class="fnname">eq_ignore_ascii_case</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks that two strings are an ASCII case-insensitive match.</p>
<p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>,
but without allocating and copying temporaries.</p>
<h5 id="examples-55"><a href="#examples-55">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(<span class="string">&quot;Ferris&quot;</span>.<span class="ident">eq_ignore_ascii_case</span>(<span class="string">&quot;FERRIS&quot;</span>));
<span class="macro">assert!</span>(<span class="string">&quot;FerrÃ¶s&quot;</span>.<span class="ident">eq_ignore_ascii_case</span>(<span class="string">&quot;FERRÃ¶S&quot;</span>));
<span class="macro">assert!</span>(<span class="op">!</span><span class="string">&quot;FerrÃ¶s&quot;</span>.<span class="ident">eq_ignore_ascii_case</span>(<span class="string">&quot;FERRÃ–S&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert!(%22Ferris%22.eq_ignore_ascii_case(%22FERRIS%22))%3B%0Aassert!(%22Ferr%C3%B6s%22.eq_ignore_ascii_case(%22FERR%C3%B6S%22))%3B%0Aassert!(!%22Ferr%C3%B6s%22.eq_ignore_ascii_case(%22FERR%C3%96S%22))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.make_ascii_uppercase" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2400-2404">source</a></span><a href="#method.make_ascii_uppercase" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.make_ascii_uppercase" class="fnname">make_ascii_uppercase</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Converts this string to its ASCII upper case equivalent in-place.</p>
<p>ASCII letters â€˜aâ€™ to â€˜zâ€™ are mapped to â€˜Aâ€™ to â€˜Zâ€™,
but non-ASCII letters are unchanged.</p>
<p>To return a new uppercased value without modifying the existing one, use
<a href="#method.to_ascii_uppercase"><code>to_ascii_uppercase()</code></a>.</p>
<h5 id="examples-56"><a href="#examples-56">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;GrÃ¼ÃŸe, JÃ¼rgen â¤&quot;</span>);

<span class="ident">s</span>.<span class="ident">make_ascii_uppercase</span>();

<span class="macro">assert_eq!</span>(<span class="string">&quot;GRÃ¼ÃŸE, JÃ¼RGEN â¤&quot;</span>, <span class="ident">s</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20String%3A%3Afrom(%22Gr%C3%BC%C3%9Fe%2C%20J%C3%BCrgen%20%E2%9D%A4%22)%3B%0A%0As.make_ascii_uppercase()%3B%0A%0Aassert_eq!(%22GR%C3%BC%C3%9FE%2C%20J%C3%BCRGEN%20%E2%9D%A4%22%2C%20s)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.make_ascii_lowercase" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2427-2431">source</a></span><a href="#method.make_ascii_lowercase" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.make_ascii_lowercase" class="fnname">make_ascii_lowercase</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Converts this string to its ASCII lower case equivalent in-place.</p>
<p>ASCII letters â€˜Aâ€™ to â€˜Zâ€™ are mapped to â€˜aâ€™ to â€˜zâ€™,
but non-ASCII letters are unchanged.</p>
<p>To return a new lowercased value without modifying the existing one, use
<a href="#method.to_ascii_lowercase"><code>to_ascii_lowercase()</code></a>.</p>
<h5 id="examples-57"><a href="#examples-57">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;GRÃœÃŸE, JÃœRGEN â¤&quot;</span>);

<span class="ident">s</span>.<span class="ident">make_ascii_lowercase</span>();

<span class="macro">assert_eq!</span>(<span class="string">&quot;grÃœÃŸe, jÃœrgen â¤&quot;</span>, <span class="ident">s</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20String%3A%3Afrom(%22GR%C3%9C%C3%9FE%2C%20J%C3%9CRGEN%20%E2%9D%A4%22)%3B%0A%0As.make_ascii_lowercase()%3B%0A%0Aassert_eq!(%22gr%C3%9C%C3%9Fe%2C%20j%C3%9Crgen%20%E2%9D%A4%22%2C%20s)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.escape_debug" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2470-2480">source</a></span><a href="#method.escape_debug" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.escape_debug" class="fnname">escape_debug</a>(&amp;self) -&gt; <a class="struct" href="str/struct.EscapeDebug.html" title="struct core::str::EscapeDebug">EscapeDebug</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.EscapeDebug.html" title="struct core::str::EscapeDebug">EscapeDebug</a>&lt;'a&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.EscapeDebug.html" title="struct core::str::EscapeDebug">EscapeDebug</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.char.html">char</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Return an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_debug" title="char::escape_debug"><code>char::escape_debug</code></a>.</p>
<p>Note: only extended grapheme codepoints that begin the string will be
escaped.</p>
<h5 id="examples-58"><a href="#examples-58">Examples</a></h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for</span> <span class="ident">c</span> <span class="kw">in</span> <span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_debug</span>() {
    <span class="macro">print!</span>(<span class="string">&quot;{c}&quot;</span>);
}
<span class="macro">println!</span>();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afor%20c%20in%20%22%E2%9D%A4%5Cn!%22.escape_debug()%20%7B%0A%20%20%20%20print!(%22%7Bc%7D%22)%3B%0A%7D%0Aprintln!()%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_debug</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprintln!(%22%7B%7D%22%2C%20%22%E2%9D%A4%5Cn!%22.escape_debug())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;â¤\\n!&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprintln!(%22%E2%9D%A4%5C%5Cn!%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_debug</span>().<span class="ident">to_string</span>(), <span class="string">&quot;â¤\\n!&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22%E2%9D%A4%5Cn!%22.escape_debug().to_string()%2C%20%22%E2%9D%A4%5C%5Cn!%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.escape_default" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2516-2518">source</a></span><a href="#method.escape_default" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.escape_default" class="fnname">escape_default</a>(&amp;self) -&gt; <a class="struct" href="str/struct.EscapeDefault.html" title="struct core::str::EscapeDefault">EscapeDefault</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.EscapeDefault.html" title="struct core::str::EscapeDefault">EscapeDefault</a>&lt;'a&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.EscapeDefault.html" title="struct core::str::EscapeDefault">EscapeDefault</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.char.html">char</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Return an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_default" title="char::escape_default"><code>char::escape_default</code></a>.</p>
<h5 id="examples-59"><a href="#examples-59">Examples</a></h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for</span> <span class="ident">c</span> <span class="kw">in</span> <span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_default</span>() {
    <span class="macro">print!</span>(<span class="string">&quot;{c}&quot;</span>);
}
<span class="macro">println!</span>();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afor%20c%20in%20%22%E2%9D%A4%5Cn!%22.escape_default()%20%7B%0A%20%20%20%20print!(%22%7Bc%7D%22)%3B%0A%7D%0Aprintln!()%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_default</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprintln!(%22%7B%7D%22%2C%20%22%E2%9D%A4%5Cn!%22.escape_default())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;\\u{{2764}}\\n!&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprintln!(%22%5C%5Cu%7B%7B2764%7D%7D%5C%5Cn!%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_default</span>().<span class="ident">to_string</span>(), <span class="string">&quot;\\u{2764}\\n!&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22%E2%9D%A4%5Cn!%22.escape_default().to_string()%2C%20%22%5C%5Cu%7B2764%7D%5C%5Cn!%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.escape_unicode" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2554-2556">source</a></span><a href="#method.escape_unicode" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.escape_unicode" class="fnname">escape_unicode</a>(&amp;self) -&gt; <a class="struct" href="str/struct.EscapeUnicode.html" title="struct core::str::EscapeUnicode">EscapeUnicode</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.EscapeUnicode.html" title="struct core::str::EscapeUnicode">EscapeUnicode</a>&lt;'a&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait core::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.EscapeUnicode.html" title="struct core::str::EscapeUnicode">EscapeUnicode</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.char.html">char</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Return an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_unicode" title="char::escape_unicode"><code>char::escape_unicode</code></a>.</p>
<h5 id="examples-60"><a href="#examples-60">Examples</a></h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for</span> <span class="ident">c</span> <span class="kw">in</span> <span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_unicode</span>() {
    <span class="macro">print!</span>(<span class="string">&quot;{c}&quot;</span>);
}
<span class="macro">println!</span>();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afor%20c%20in%20%22%E2%9D%A4%5Cn!%22.escape_unicode()%20%7B%0A%20%20%20%20print!(%22%7Bc%7D%22)%3B%0A%7D%0Aprintln!()%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_unicode</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprintln!(%22%7B%7D%22%2C%20%22%E2%9D%A4%5Cn!%22.escape_unicode())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;\\u{{2764}}\\u{{a}}\\u{{21}}&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprintln!(%22%5C%5Cu%7B%7B2764%7D%7D%5C%5Cu%7B%7Ba%7D%7D%5C%5Cu%7B%7B21%7D%7D%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_unicode</span>().<span class="ident">to_string</span>(), <span class="string">&quot;\\u{2764}\\u{a}\\u{21}&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22%E2%9D%A4%5Cn!%22.escape_unicode().to_string()%2C%20%22%5C%5Cu%7B2764%7D%5C%5Cu%7Ba%7D%5C%5Cu%7B21%7D%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsMut%3Cstr%3E" class="impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span> Â· <a class="srclink" href="../src/core/convert/mod.rs.html#636-641">source</a></span><a href="#impl-AsMut%3Cstr%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#638-640">source</a></span><a href="#method.as_mut" class="anchor"></a><h4 class="code-header">fn <a href="convert/trait.AsMut.html#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'><p>Converts this type into a mutable reference of the (usually inferred) input type.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsRef%3C%5Bu8%5D%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#2560-2565">source</a></span><a href="#impl-AsRef%3C%5Bu8%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="primitive.slice.html">[</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ref-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#2562-2564">source</a></span><a href="#method.as_ref-1" class="anchor"></a><h4 class="code-header">fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; <a class="primitive" href="primitive.slice.html">&amp;[</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a></h4></section></summary><div class='docblock'><p>Converts this type into a shared reference of the (usually inferred) input type.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsRef%3Cstr%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#628-633">source</a></span><a href="#impl-AsRef%3Cstr%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ref" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#630-632">source</a></span><a href="#method.as_ref" class="anchor"></a><h4 class="code-header">fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'><p>Converts this type into a shared reference of the (usually inferred) input type.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/fmt/mod.rs.html#2176-2198">source</a></span><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/fmt/mod.rs.html#2177-2197">source</a></span><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Default" class="impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/87864" title="Tracking issue for const_default_impls">unstable</a></span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2569-2575">source</a></span><a href="#impl-Default" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="default/trait.Default.html" title="trait core::default::Default">Default</a> for &amp;<a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.default" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/87864" title="Tracking issue for const_default_impls">unstable</a></span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2572-2574">source</a></span><a href="#method.default" class="anchor"></a><h4 class="code-header">fn <a href="default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Creates an empty str</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Default-1" class="impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.28.0">1.28.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2578-2585">source</a></span><a href="#impl-Default-1" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="default/trait.Default.html" title="trait core::default::Default">Default</a> for &amp;mut <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.default-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#2581-2584">source</a></span><a href="#method.default-1" class="anchor"></a><h4 class="code-header">fn <a href="default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Creates an empty mutable str</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Display" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/fmt/mod.rs.html#2201-2205">source</a></span><a href="#impl-Display" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/fmt/mod.rs.html#2202-2204">source</a></span><a href="#method.fmt-1" class="anchor"></a><h4 class="code-header">fn <a href="fmt/trait.Display.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="fmt/trait.Display.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Hash" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/hash/mod.rs.html#861-866">source</a></span><a href="#impl-Hash" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/hash/mod.rs.html#863-865">source</a></span><a href="#method.hash" class="anchor"></a><h4 class="code-header">fn <a href="hash/trait.Hash.html#tymethod.hash" class="fnname">hash</a>&lt;H:&nbsp;<a class="trait" href="hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: <a class="primitive" href="primitive.reference.html">&amp;mut </a>H)</h4></section></summary><div class='docblock'><p>Feeds this value into the given <a href="hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> Â· <a class="srclink" href="../src/core/hash/mod.rs.html#237-244">source</a></span><a href="#method.hash_slice" class="anchor"></a><h4 class="code-header">fn <a href="hash/trait.Hash.html#method.hash_slice" class="fnname">hash_slice</a>&lt;H:&nbsp;<a class="trait" href="hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(data: <a class="primitive" href="primitive.slice.html">&amp;[Self]</a>, state: <a class="primitive" href="primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Feeds a slice of this type into the given <a href="hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3CI%3E" class="impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#57-67">source</a></span><a href="#impl-Index%3CI%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;I&gt; <a class="trait" href="ops/trait.Index.html" title="trait core::ops::Index">Index</a>&lt;I&gt; for <a class="primitive" href="primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output" class="anchor"></a><h4 class="code-header">type <a href="ops/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><div class='docblock'><p>The returned type after indexing.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#64-66">source</a></span><a href="#method.index" class="anchor"></a><h4 class="code-header">fn <a href="ops/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: I) -&gt; &amp;I::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the indexing (<code>container[index]</code>) operation. <a href="ops/trait.Index.html#tymethod.index">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CI%3E" class="impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#71-79">source</a></span><a href="#impl-IndexMut%3CI%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;I&gt; <a class="trait" href="ops/trait.IndexMut.html" title="trait core::ops::IndexMut">IndexMut</a>&lt;I&gt; for <a class="primitive" href="primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#76-78">source</a></span><a href="#method.index_mut" class="anchor"></a><h4 class="code-header">fn <a href="ops/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: I) -&gt; &amp;mut I::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="ops/trait.IndexMut.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Ord" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#18-23">source</a></span><a href="#impl-Ord" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="docblock"><p>Implements ordering of strings.</p>
<p>Strings are ordered  <a href="cmp/trait.Ord.html#lexicographical-comparison">lexicographically</a> by their byte values. This orders Unicode code
points based on their positions in the code charts. This is not necessarily the same as
â€œalphabeticalâ€ order, which varies by language and locale. Sorting strings according to
culturally-accepted standards requires locale-specific data that is outside the scope of
the <code>str</code> type.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#20-22">source</a></span><a href="#method.cmp" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#tymethod.cmp" class="fnname">cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'><p>This method returns an <a href="cmp/enum.Ordering.html" title="Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.max" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> Â· <a class="srclink" href="../src/core/cmp.rs.html#796-801">source</a></span><a href="#method.max" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.max" class="fnname">max</a>(self, other: Self) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Compares and returns the maximum of two values. <a href="cmp/trait.Ord.html#method.max">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.min" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> Â· <a class="srclink" href="../src/core/cmp.rs.html#816-821">source</a></span><a href="#method.min" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.min" class="fnname">min</a>(self, other: Self) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Compares and returns the minimum of two values. <a href="cmp/trait.Ord.html#method.min">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> Â· <a class="srclink" href="../src/core/cmp.rs.html#841-853">source</a></span><a href="#method.clamp" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.clamp" class="fnname">clamp</a>(self, min: Self, max: Self) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Restrict a value to a certain interval. <a href="cmp/trait.Ord.html#method.clamp">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3Cstr%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#26-35">source</a></span><a href="#impl-PartialEq%3Cstr%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#28-30">source</a></span><a href="#method.eq" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#32-34">source</a></span><a href="#method.ne" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3Cstr%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#48-53">source</a></span><a href="#impl-PartialOrd%3Cstr%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="docblock"><p>Implements comparison operations on strings.</p>
<p>Strings are compared <a href="cmp/trait.Ord.html#lexicographical-comparison">lexicographically</a> by their byte values. This compares Unicode code
points based on their positions in the code charts. This is not necessarily the same as
â€œalphabeticalâ€ order, which varies by language and locale. Comparing strings according to
culturally-accepted standards requires locale-specific data that is outside the scope of
the <code>str</code> type.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#50-52">source</a></span><a href="#method.partial_cmp" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#1100-1102">source</a></span><a href="#method.lt" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#1120-1126">source</a></span><a href="#method.le" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#1143-1145">source</a></span><a href="#method.gt" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#1163-1165">source</a></span><a href="#method.ge" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Pattern%3C%27a%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/pattern.rs.html#935-977">source</a></span><a href="#impl-Pattern%3C%27a%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, 'b&gt; <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt; for &amp;'b <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="docblock"><p>Non-allocating substring search.</p>
<p>Will handle the pattern <code>&quot;&quot;</code> as returning empty matches at each character
boundary.</p>
<h4 id="examples-62"><a href="#examples-62">Examples</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;Hello world&quot;</span>.<span class="ident">find</span>(<span class="string">&quot;world&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">6</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22Hello%20world%22.find(%22world%22)%2C%20Some(6))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_prefix_of" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/pattern.rs.html#945-947">source</a></span><a href="#method.is_prefix_of" class="anchor"></a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.is_prefix_of" class="fnname">is_prefix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></span></summary><div class="docblock"><p>Checks whether the pattern matches at the front of the haystack.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.strip_prefix_of" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/pattern.rs.html#951-958">source</a></span><a href="#method.strip_prefix_of" class="anchor"></a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.strip_prefix_of" class="fnname">strip_prefix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></span></summary><div class="docblock"><p>Removes the pattern from the front of haystack, if it matches.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_suffix_of" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/pattern.rs.html#962-964">source</a></span><a href="#method.is_suffix_of" class="anchor"></a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.is_suffix_of" class="fnname">is_suffix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></span></summary><div class="docblock"><p>Checks whether the pattern matches at the back of the haystack.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.strip_suffix_of" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/pattern.rs.html#968-976">source</a></span><a href="#method.strip_suffix_of" class="anchor"></a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.strip_suffix_of" class="fnname">strip_suffix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></span></summary><div class="docblock"><p>Removes the pattern from the back of haystack, if it matches.</p>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Searcher" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Searcher" class="anchor"></a><h4 class="code-header">type <a href="str/pattern/trait.Pattern.html#associatedtype.Searcher" class="associatedtype">Searcher</a> = <a class="struct" href="str/pattern/struct.StrSearcher.html" title="struct core::str::pattern::StrSearcher">StrSearcher</a>&lt;'a, 'b&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></span><div class='docblock'><p>Associated searcher for this pattern</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_searcher" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/pattern.rs.html#939-941">source</a></span><a href="#method.into_searcher" class="anchor"></a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#tymethod.into_searcher" class="fnname">into_searcher</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="str/pattern/struct.StrSearcher.html" title="struct core::str::pattern::StrSearcher">StrSearcher</a>&lt;'a, 'b&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></span><div class='docblock'><p>Constructs the associated searcher from
<code>self</code> and the <code>haystack</code> to search in. <a href="str/pattern/trait.Pattern.html#tymethod.into_searcher">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_contained_in" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/pattern.rs.html#108-110">source</a></span><a href="#method.is_contained_in" class="anchor"></a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.is_contained_in" class="fnname">is_contained_in</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></span><div class='docblock'><p>Checks whether the pattern matches anywhere in the haystack</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E" class="impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#102-128">source</a></span><a href="#impl-SliceIndex%3Cstr%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeFull.html" title="struct core::ops::RangeFull">RangeFull</a></h3></section></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[..]</code> or <code>&amp;mut self[..]</code>.</p>
<p>Returns a slice of the whole string, i.e., returns <code>&amp;self</code> or <code>&amp;mut self</code>. Equivalent to <code>&amp;self[0 .. len]</code> or <code>&amp;mut self[0 .. len]</code>. Unlike
other indexing operations, this can never panic.</p>
<p>This operation is <em>O</em>(1).</p>
<p>Prior to 1.20.0, these indexing operations were still supported by
direct implementation of <code>Index</code> and <code>IndexMut</code>.</p>
<p>Equivalent to <code>&amp;self[0 .. len]</code> or <code>&amp;mut self[0 .. len]</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-1" class="anchor"></a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'><p>The output type returned by methods.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#105-107">source</a></span><a href="#method.get-1" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fnname">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_mut-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#109-111">source</a></span><a href="#method.get_mut-1" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fnname">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#113-115">source</a></span><a href="#method.get_unchecked-1" class="anchor"></a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fnname">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked_mut-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#117-119">source</a></span><a href="#method.get_unchecked_mut-1" class="anchor"></a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fnname">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#121-123">source</a></span><a href="#method.index-1" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fnname">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#125-127">source</a></span><a href="#method.index_mut-1" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fnname">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-1" class="impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#167-236">source</a></span><a href="#impl-SliceIndex%3Cstr%3E-1" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.Range.html" title="struct core::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></section></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[begin .. end]</code> or <code>&amp;mut self[begin .. end]</code>.</p>
<p>Returns a slice of the given string from the byte range
[<code>begin</code>, <code>end</code>).</p>
<p>This operation is <em>O</em>(1).</p>
<p>Prior to 1.20.0, these indexing operations were still supported by
direct implementation of <code>Index</code> and <code>IndexMut</code>.</p>
<h4 id="panics-3"><a href="#panics-3">Panics</a></h4>
<p>Panics if <code>begin</code> or <code>end</code> does not point to the starting byte offset of
a character (as defined by <code>is_char_boundary</code>), if <code>begin &gt; end</code>, or if
<code>end &gt; len</code>.</p>
<h4 id="examples-61"><a href="#examples-61">Examples</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">s</span>[<span class="number">0</span> .. <span class="number">1</span>], <span class="string">&quot;L&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">s</span>[<span class="number">1</span> .. <span class="number">9</span>], <span class="string">&quot;Ã¶we è€&quot;</span>);

<span class="comment">// these will panic:</span>
<span class="comment">// byte 2 lies within `Ã¶`:</span>
<span class="comment">// &amp;s[2 ..3];</span>

<span class="comment">// byte 8 lies within `è€`</span>
<span class="comment">// &amp;s[1 .. 8];</span>

<span class="comment">// byte 100 is outside the string</span>
<span class="comment">// &amp;s[3 .. 100];</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%22%3B%0Aassert_eq!(%26s%5B0%20..%201%5D%2C%20%22L%22)%3B%0A%0Aassert_eq!(%26s%5B1%20..%209%5D%2C%20%22%C3%B6we%20%E8%80%81%22)%3B%0A%0A%2F%2F%20these%20will%20panic%3A%0A%2F%2F%20byte%202%20lies%20within%20%60%C3%B6%60%3A%0A%2F%2F%20%26s%5B2%20..3%5D%3B%0A%0A%2F%2F%20byte%208%20lies%20within%20%60%E8%80%81%60%0A%2F%2F%20%26s%5B1%20..%208%5D%3B%0A%0A%2F%2F%20byte%20100%20is%20outside%20the%20string%0A%2F%2F%20%26s%5B3%20..%20100%5D%3B%0A%7D&amp;edition=2021">Run</a></div>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-2" class="anchor"></a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'><p>The output type returned by methods.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#170-182">source</a></span><a href="#method.get-2" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fnname">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_mut-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#184-195">source</a></span><a href="#method.get_mut-2" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fnname">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#197-204">source</a></span><a href="#method.get_unchecked-2" class="anchor"></a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fnname">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked_mut-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#206-212">source</a></span><a href="#method.get_unchecked_mut-2" class="anchor"></a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fnname">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#214-220">source</a></span><a href="#method.index-2" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fnname">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#222-235">source</a></span><a href="#method.index_mut-2" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fnname">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-2" class="impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#255-307">source</a></span><a href="#impl-SliceIndex%3Cstr%3E-2" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeTo.html" title="struct core::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></section></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[.. end]</code> or <code>&amp;mut self[.. end]</code>.</p>
<p>Returns a slice of the given string from the byte range [0, <code>end</code>).
Equivalent to <code>&amp;self[0 .. end]</code> or <code>&amp;mut self[0 .. end]</code>.</p>
<p>This operation is <em>O</em>(1).</p>
<p>Prior to 1.20.0, these indexing operations were still supported by
direct implementation of <code>Index</code> and <code>IndexMut</code>.</p>
<h4 id="panics-4"><a href="#panics-4">Panics</a></h4>
<p>Panics if <code>end</code> does not point to the starting byte offset of a
character (as defined by <code>is_char_boundary</code>), or if <code>end &gt; len</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-3" class="anchor"></a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'><p>The output type returned by methods.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#258-266">source</a></span><a href="#method.get-3" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fnname">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_mut-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#268-276">source</a></span><a href="#method.get_mut-3" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fnname">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#278-282">source</a></span><a href="#method.get_unchecked-3" class="anchor"></a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fnname">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked_mut-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#284-288">source</a></span><a href="#method.get_unchecked_mut-3" class="anchor"></a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fnname">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#290-296">source</a></span><a href="#method.index-3" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fnname">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#298-306">source</a></span><a href="#method.index_mut-3" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fnname">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-3" class="impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#326-383">source</a></span><a href="#impl-SliceIndex%3Cstr%3E-3" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeFrom.html" title="struct core::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></section></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[begin ..]</code> or <code>&amp;mut self[begin ..]</code>.</p>
<p>Returns a slice of the given string from the byte range [<code>begin</code>, <code>len</code>).
Equivalent to <code>&amp;self[begin .. len]</code> or <code>&amp;mut self[begin .. len]</code>.</p>
<p>This operation is <em>O</em>(1).</p>
<p>Prior to 1.20.0, these indexing operations were still supported by
direct implementation of <code>Index</code> and <code>IndexMut</code>.</p>
<h4 id="panics-5"><a href="#panics-5">Panics</a></h4>
<p>Panics if <code>begin</code> does not point to the starting byte offset of
a character (as defined by <code>is_char_boundary</code>), or if <code>begin &gt; len</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-4" class="anchor"></a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'><p>The output type returned by methods.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get-4" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#329-337">source</a></span><a href="#method.get-4" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fnname">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_mut-4" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#339-347">source</a></span><a href="#method.get_mut-4" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fnname">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked-4" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#349-356">source</a></span><a href="#method.get_unchecked-4" class="anchor"></a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fnname">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked_mut-4" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#358-364">source</a></span><a href="#method.get_unchecked_mut-4" class="anchor"></a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fnname">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-4" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#366-372">source</a></span><a href="#method.index-4" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fnname">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut-4" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#374-382">source</a></span><a href="#method.index_mut-4" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fnname">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-4" class="impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: unstable)</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#403-437">source</a></span><a href="#impl-SliceIndex%3Cstr%3E-4" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeInclusive.html" title="struct core::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></section></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[begin ..= end]</code> or <code>&amp;mut self[begin ..= end]</code>.</p>
<p>Returns a slice of the given string from the byte range
[<code>begin</code>, <code>end</code>]. Equivalent to <code>&amp;self [begin .. end + 1]</code> or <code>&amp;mut self[begin .. end + 1]</code>, except if <code>end</code> has the maximum value for
<code>usize</code>.</p>
<p>This operation is <em>O</em>(1).</p>
<h4 id="panics-6"><a href="#panics-6">Panics</a></h4>
<p>Panics if <code>begin</code> does not point to the starting byte offset of
a character (as defined by <code>is_char_boundary</code>), if <code>end</code> does not point
to the ending byte offset of a character (<code>end + 1</code> is either a starting
byte offset or equal to <code>len</code>), if <code>begin &gt; end</code>, or if <code>end &gt;= len</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-5" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-5" class="anchor"></a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'><p>The output type returned by methods.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get-5" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#406-408">source</a></span><a href="#method.get-5" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fnname">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_mut-5" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#410-412">source</a></span><a href="#method.get_mut-5" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fnname">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked-5" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#414-417">source</a></span><a href="#method.get_unchecked-5" class="anchor"></a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fnname">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked_mut-5" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#419-422">source</a></span><a href="#method.get_unchecked_mut-5" class="anchor"></a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fnname">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-5" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#424-429">source</a></span><a href="#method.index-5" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fnname">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut-5" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#431-436">source</a></span><a href="#method.index_mut-5" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fnname">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-5" class="impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: unstable)</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#455-489">source</a></span><a href="#impl-SliceIndex%3Cstr%3E-5" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeToInclusive.html" title="struct core::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></section></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[..= end]</code> or <code>&amp;mut self[..= end]</code>.</p>
<p>Returns a slice of the given string from the byte range [0, <code>end</code>].
Equivalent to <code>&amp;self [0 .. end + 1]</code>, except if <code>end</code> has the maximum
value for <code>usize</code>.</p>
<p>This operation is <em>O</em>(1).</p>
<h4 id="panics-7"><a href="#panics-7">Panics</a></h4>
<p>Panics if <code>end</code> does not point to the ending byte offset of a character
(<code>end + 1</code> is either a starting byte offset as defined by
<code>is_char_boundary</code>, or equal to <code>len</code>), or if <code>end &gt;= len</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-6" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-6" class="anchor"></a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'><p>The output type returned by methods.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get-6" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#458-460">source</a></span><a href="#method.get-6" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fnname">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_mut-6" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#462-464">source</a></span><a href="#method.get_mut-6" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fnname">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked-6" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#466-469">source</a></span><a href="#method.get_unchecked-6" class="anchor"></a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fnname">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked_mut-6" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#471-474">source</a></span><a href="#method.get_unchecked_mut-6" class="anchor"></a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fnname">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-6" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#476-481">source</a></span><a href="#method.index-6" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fnname">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a shared reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut-6" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#483-488">source</a></span><a href="#method.index_mut-6" class="anchor"></a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fnname">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class='docblock'><p>Returns a mutable reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><section id="impl-Eq" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#38">source</a></span><a href="#impl-Eq" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe" class="impl has-srclink"><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait core::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-Send" class="impl has-srclink"><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-Sized" class="impl has-srclink"><a href="#impl-Sized" class="anchor"></a><h3 class="code-header in-band">impl !<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-Sync" class="impl has-srclink"><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-Unpin" class="impl has-srclink"><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-UnwindSafe" class="impl has-srclink"><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="panic/trait.UnwindSafe.html" title="trait core::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/any.rs.html#132-136">source</a></span><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/any.rs.html#133-135">source</a></span><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#209-214">source</a></span><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> Â· <a class="srclink" href="../src/core/borrow.rs.html#211-213">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#218-222">source</a></span><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> Â· <a class="srclink" href="../src/core/borrow.rs.html#219-221">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="core" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.62.0 (a8314ef7d 2022-06-27)" ></div>
</body></html>