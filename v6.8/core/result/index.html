<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Error handling with the `Result` type."><title>core::result - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-fa3bb1812debf86c.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="core" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.1 (a28077b28 2023-12-04)" data-channel="1.74.1" data-search-js="search-8be46b629f5f14a8.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../../static.files/main-c5bd66d33317d69f.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="icon" type="image/svg+xml" href="../../static.files/logo.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../core/index.html"><img class="rust-logo" src="../../static.files/logo.svg" alt="logo"></a></nav><nav class="sidebar"><a class="logo-container" href="../../core/index.html"><img class="rust-logo" src="../../static.files/logo.svg" alt="logo"></a><h2 class="location"><a href="#">Module result</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">core</a>::<wbr><a class="mod" href="#">result</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../../src/core/result.rs.html#1-1978">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Error handling with the <code>Result</code> type.</p>
<p><a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> is the type used for returning and propagating
errors. It is an enum with the variants, <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok(T)</code></a>, representing
success and containing a value, and <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err(E)</code></a>, representing error
and containing an error value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">enum </span><span class="prelude-ty">Result</span>&lt;T, E&gt; {
   <span class="prelude-val">Ok</span>(T),
   <span class="prelude-val">Err</span>(E),
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A%23%5Ballow(dead_code)%5D%0Aenum+Result%3CT,+E%3E+%7B%0A+++Ok(T),%0A+++Err(E),%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p>Functions return <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> whenever errors are expected and
recoverable. In the <code>std</code> crate, <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> is most prominently used
for <a href="../../std/io/index.html">I/O</a>.</p>
<p>A simple function returning <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> might be
defined and used like so:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Debug)]
</span><span class="kw">enum </span>Version { Version1, Version2 }

<span class="kw">fn </span>parse_version(header: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Result</span>&lt;Version, <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str&gt; {
    <span class="kw">match </span>header.get(<span class="number">0</span>) {
        <span class="prelude-val">None </span>=&gt; <span class="prelude-val">Err</span>(<span class="string">&quot;invalid header length&quot;</span>),
        <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">1</span>) =&gt; <span class="prelude-val">Ok</span>(Version::Version1),
        <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">2</span>) =&gt; <span class="prelude-val">Ok</span>(Version::Version2),
        <span class="prelude-val">Some</span>(<span class="kw">_</span>) =&gt; <span class="prelude-val">Err</span>(<span class="string">&quot;invalid version&quot;</span>),
    }
}

<span class="kw">let </span>version = parse_version(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="kw">match </span>version {
    <span class="prelude-val">Ok</span>(v) =&gt; <span class="macro">println!</span>(<span class="string">&quot;working with version: {v:?}&quot;</span>),
    <span class="prelude-val">Err</span>(e) =&gt; <span class="macro">println!</span>(<span class="string">&quot;error parsing header: {e:?}&quot;</span>),
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A%23%5Bderive(Debug)%5D%0Aenum+Version+%7B+Version1,+Version2+%7D%0A%0Afn+parse_version(header:+%26%5Bu8%5D)+-%3E+Result%3CVersion,+%26'static+str%3E+%7B%0A++++match+header.get(0)+%7B%0A++++++++None+=%3E+Err(%22invalid+header+length%22),%0A++++++++Some(%261)+=%3E+Ok(Version::Version1),%0A++++++++Some(%262)+=%3E+Ok(Version::Version2),%0A++++++++Some(_)+=%3E+Err(%22invalid+version%22),%0A++++%7D%0A%7D%0A%0Alet+version+=+parse_version(%26%5B1,+2,+3,+4%5D);%0Amatch+version+%7B%0A++++Ok(v)+=%3E+println!(%22working+with+version:+%7Bv:?%7D%22),%0A++++Err(e)+=%3E+println!(%22error+parsing+header:+%7Be:?%7D%22),%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p>Pattern matching on <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a>s is clear and straightforward for
simple cases, but <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> comes with some convenience methods
that make working with it more succinct.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>good_result: <span class="prelude-ty">Result</span>&lt;i32, i32&gt; = <span class="prelude-val">Ok</span>(<span class="number">10</span>);
<span class="kw">let </span>bad_result: <span class="prelude-ty">Result</span>&lt;i32, i32&gt; = <span class="prelude-val">Err</span>(<span class="number">10</span>);

<span class="comment">// The `is_ok` and `is_err` methods do what they say.
</span><span class="macro">assert!</span>(good_result.is_ok() &amp;&amp; !good_result.is_err());
<span class="macro">assert!</span>(bad_result.is_err() &amp;&amp; !bad_result.is_ok());

<span class="comment">// `map` consumes the `Result` and produces another.
</span><span class="kw">let </span>good_result: <span class="prelude-ty">Result</span>&lt;i32, i32&gt; = good_result.map(|i| i + <span class="number">1</span>);
<span class="kw">let </span>bad_result: <span class="prelude-ty">Result</span>&lt;i32, i32&gt; = bad_result.map(|i| i - <span class="number">1</span>);

<span class="comment">// Use `and_then` to continue the computation.
</span><span class="kw">let </span>good_result: <span class="prelude-ty">Result</span>&lt;bool, i32&gt; = good_result.and_then(|i| <span class="prelude-val">Ok</span>(i == <span class="number">11</span>));

<span class="comment">// Use `or_else` to handle the error.
</span><span class="kw">let </span>bad_result: <span class="prelude-ty">Result</span>&lt;i32, i32&gt; = bad_result.or_else(|i| <span class="prelude-val">Ok</span>(i + <span class="number">20</span>));

<span class="comment">// Consume the result and return the contents with `unwrap`.
</span><span class="kw">let </span>final_awesome_result = good_result.unwrap();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+good_result:+Result%3Ci32,+i32%3E+=+Ok(10);%0Alet+bad_result:+Result%3Ci32,+i32%3E+=+Err(10);%0A%0A//+The+%60is_ok%60+and+%60is_err%60+methods+do+what+they+say.%0Aassert!(good_result.is_ok()+%26%26+!good_result.is_err());%0Aassert!(bad_result.is_err()+%26%26+!bad_result.is_ok());%0A%0A//+%60map%60+consumes+the+%60Result%60+and+produces+another.%0Alet+good_result:+Result%3Ci32,+i32%3E+=+good_result.map(%7Ci%7C+i+%2B+1);%0Alet+bad_result:+Result%3Ci32,+i32%3E+=+bad_result.map(%7Ci%7C+i+-+1);%0A%0A//+Use+%60and_then%60+to+continue+the+computation.%0Alet+good_result:+Result%3Cbool,+i32%3E+=+good_result.and_then(%7Ci%7C+Ok(i+==+11));%0A%0A//+Use+%60or_else%60+to+handle+the+error.%0Alet+bad_result:+Result%3Ci32,+i32%3E+=+bad_result.or_else(%7Ci%7C+Ok(i+%2B+20));%0A%0A//+Consume+the+result+and+return+the+contents+with+%60unwrap%60.%0Alet+final_awesome_result+=+good_result.unwrap();%0A%7D&amp;edition=2021">Run</a></div>
<h2 id="results-must-be-used"><a href="#results-must-be-used">Results must be used</a></h2>
<p>A common problem with using return values to indicate errors is
that it is easy to ignore the return value, thus failing to handle
the error. <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> is annotated with the <code>#[must_use]</code> attribute,
which will cause the compiler to issue a warning when a Result
value is ignored. This makes <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> especially useful with
functions that may encounter errors but don’t otherwise return a
useful value.</p>
<p>Consider the <a href="../../std/io/trait.Write.html#method.write_all" title="io::Write::write_all"><code>write_all</code></a> method defined for I/O types
by the <a href="../../std/io/trait.Write.html" title="io::Write"><code>Write</code></a> trait:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io;

<span class="kw">trait </span>Write {
    <span class="kw">fn </span>write_all(<span class="kw-2">&amp;mut </span><span class="self">self</span>, bytes: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Result</span>&lt;(), io::Error&gt;;
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::io;%0A%0Atrait+Write+%7B%0A++++fn+write_all(%26mut+self,+bytes:+%26%5Bu8%5D)+-%3E+Result%3C(),+io::Error%3E;%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p><em>Note: The actual definition of <a href="../../std/io/trait.Write.html" title="io::Write"><code>Write</code></a> uses <a href="../../std/io/type.Result.html" title="io::Result"><code>io::Result</code></a>, which
is just a synonym for <code><a href="enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, <a href="../../std/io/struct.Error.html" title="io::Error">io::Error</a>&gt;</code>.</em></p>
<p>This method doesn’t produce a value, but the write may
fail. It’s crucial to handle the error case, and <em>not</em> write
something like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>file = File::create(<span class="string">&quot;valuable_data.txt&quot;</span>).unwrap();
<span class="comment">// If `write_all` errors, then we&#39;ll never know, because the return
// value is ignored.
</span>file.write_all(<span class="string">b&quot;important message&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_must_use)%5D+//+%5Co/%0Afn+main()+%7B%0Ause+std::fs::File;%0Ause+std::io::prelude::*;%0A%0Alet+mut+file+=+File::create(%22valuable_data.txt%22).unwrap();%0A//+If+%60write_all%60+errors,+then+we'll+never+know,+because+the+return%0A//+value+is+ignored.%0Afile.write_all(b%22important+message%22);%0A%7D&amp;edition=2021">Run</a></div>
<p>If you <em>do</em> write that in Rust, the compiler will give you a
warning (by default, controlled by the <code>unused_must_use</code> lint).</p>
<p>You might instead, if you don’t want to handle the error, simply
assert success with <a href="enum.Result.html#method.expect" title="method core::result::Result::expect"><code>expect</code></a>. This will panic if the
write fails, providing a marginally useful message indicating why:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>file = File::create(<span class="string">&quot;valuable_data.txt&quot;</span>).unwrap();
file.write_all(<span class="string">b&quot;important message&quot;</span>).expect(<span class="string">&quot;failed to write message&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::fs::File;%0Ause+std::io::prelude::*;%0A%0Alet+mut+file+=+File::create(%22valuable_data.txt%22).unwrap();%0Afile.write_all(b%22important+message%22).expect(%22failed+to+write+message%22);%0A%7D&amp;edition=2021">Run</a></div>
<p>You might also simply assert success:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(file.write_all(<span class="string">b&quot;important message&quot;</span>).is_ok());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::fs::File;%0Ause+std::io::prelude::*;%0Alet+mut+file+=+File::create(%22valuable_data.txt%22).unwrap();%0Aassert!(file.write_all(b%22important+message%22).is_ok());%0A%7D&amp;edition=2021">Run</a></div>
<p>Or propagate the error up the call stack with <a href="../ops/trait.Try.html" title="trait core::ops::Try"><code>?</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>write_message() -&gt; io::Result&lt;()&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>file = File::create(<span class="string">&quot;valuable_data.txt&quot;</span>)<span class="question-mark">?</span>;
    file.write_all(<span class="string">b&quot;important message&quot;</span>)<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::fs::File;%0Ause+std::io::prelude::*;%0Ause+std::io;%0A%23%5Ballow(dead_code)%5D%0Afn+write_message()+-%3E+io::Result%3C()%3E+%7B%0A++++let+mut+file+=+File::create(%22valuable_data.txt%22)?;%0A++++file.write_all(b%22important+message%22)?;%0A++++Ok(())%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<h2 id="the-question-mark-operator-"><a href="#the-question-mark-operator-">The question mark operator, <code>?</code></a></h2>
<p>When writing code that calls many functions that return the
<a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> type, the error handling can be tedious. The question mark
operator, <a href="../ops/trait.Try.html" title="trait core::ops::Try"><code>?</code></a>, hides some of the boilerplate of propagating errors
up the call stack.</p>
<p>It replaces this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>std::io;

<span class="kw">struct </span>Info {
    name: String,
    age: i32,
    rating: i32,
}

<span class="kw">fn </span>write_info(info: <span class="kw-2">&amp;</span>Info) -&gt; io::Result&lt;()&gt; {
    <span class="comment">// Early return on error
    </span><span class="kw">let </span><span class="kw-2">mut </span>file = <span class="kw">match </span>File::create(<span class="string">&quot;my_best_friends.txt&quot;</span>) {
           <span class="prelude-val">Err</span>(e) =&gt; <span class="kw">return </span><span class="prelude-val">Err</span>(e),
           <span class="prelude-val">Ok</span>(f) =&gt; f,
    };
    <span class="kw">if let </span><span class="prelude-val">Err</span>(e) = file.write_all(<span class="macro">format!</span>(<span class="string">&quot;name: {}\n&quot;</span>, info.name).as_bytes()) {
        <span class="kw">return </span><span class="prelude-val">Err</span>(e)
    }
    <span class="kw">if let </span><span class="prelude-val">Err</span>(e) = file.write_all(<span class="macro">format!</span>(<span class="string">&quot;age: {}\n&quot;</span>, info.age).as_bytes()) {
        <span class="kw">return </span><span class="prelude-val">Err</span>(e)
    }
    <span class="kw">if let </span><span class="prelude-val">Err</span>(e) = file.write_all(<span class="macro">format!</span>(<span class="string">&quot;rating: {}\n&quot;</span>, info.rating).as_bytes()) {
        <span class="kw">return </span><span class="prelude-val">Err</span>(e)
    }
    <span class="prelude-val">Ok</span>(())
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0Ause+std::fs::File;%0Ause+std::io::prelude::*;%0Ause+std::io;%0A%0Astruct+Info+%7B%0A++++name:+String,%0A++++age:+i32,%0A++++rating:+i32,%0A%7D%0A%0Afn+write_info(info:+%26Info)+-%3E+io::Result%3C()%3E+%7B%0A++++//+Early+return+on+error%0A++++let+mut+file+=+match+File::create(%22my_best_friends.txt%22)+%7B%0A+++++++++++Err(e)+=%3E+return+Err(e),%0A+++++++++++Ok(f)+=%3E+f,%0A++++%7D;%0A++++if+let+Err(e)+=+file.write_all(format!(%22name:+%7B%7D%5Cn%22,+info.name).as_bytes())+%7B%0A++++++++return+Err(e)%0A++++%7D%0A++++if+let+Err(e)+=+file.write_all(format!(%22age:+%7B%7D%5Cn%22,+info.age).as_bytes())+%7B%0A++++++++return+Err(e)%0A++++%7D%0A++++if+let+Err(e)+=+file.write_all(format!(%22rating:+%7B%7D%5Cn%22,+info.rating).as_bytes())+%7B%0A++++++++return+Err(e)%0A++++%7D%0A++++Ok(())%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p>With this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>std::io;

<span class="kw">struct </span>Info {
    name: String,
    age: i32,
    rating: i32,
}

<span class="kw">fn </span>write_info(info: <span class="kw-2">&amp;</span>Info) -&gt; io::Result&lt;()&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>file = File::create(<span class="string">&quot;my_best_friends.txt&quot;</span>)<span class="question-mark">?</span>;
    <span class="comment">// Early return on error
    </span>file.write_all(<span class="macro">format!</span>(<span class="string">&quot;name: {}\n&quot;</span>, info.name).as_bytes())<span class="question-mark">?</span>;
    file.write_all(<span class="macro">format!</span>(<span class="string">&quot;age: {}\n&quot;</span>, info.age).as_bytes())<span class="question-mark">?</span>;
    file.write_all(<span class="macro">format!</span>(<span class="string">&quot;rating: {}\n&quot;</span>, info.rating).as_bytes())<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0Ause+std::fs::File;%0Ause+std::io::prelude::*;%0Ause+std::io;%0A%0Astruct+Info+%7B%0A++++name:+String,%0A++++age:+i32,%0A++++rating:+i32,%0A%7D%0A%0Afn+write_info(info:+%26Info)+-%3E+io::Result%3C()%3E+%7B%0A++++let+mut+file+=+File::create(%22my_best_friends.txt%22)?;%0A++++//+Early+return+on+error%0A++++file.write_all(format!(%22name:+%7B%7D%5Cn%22,+info.name).as_bytes())?;%0A++++file.write_all(format!(%22age:+%7B%7D%5Cn%22,+info.age).as_bytes())?;%0A++++file.write_all(format!(%22rating:+%7B%7D%5Cn%22,+info.rating).as_bytes())?;%0A++++Ok(())%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p><em>It’s much nicer!</em></p>
<p>Ending the expression with <a href="../ops/trait.Try.html" title="trait core::ops::Try"><code>?</code></a> will result in the <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a>’s unwrapped value, unless the result
is <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>, in which case <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> is returned early from the enclosing function.</p>
<p><a href="../ops/trait.Try.html" title="trait core::ops::Try"><code>?</code></a> can be used in functions that return <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> because of the
early return of <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> that it provides.</p>
<h2 id="method-overview"><a href="#method-overview">Method overview</a></h2>
<p>In addition to working with pattern matching, <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> provides a
wide variety of different methods.</p>
<h3 id="querying-the-variant"><a href="#querying-the-variant">Querying the variant</a></h3>
<p>The <a href="enum.Result.html#method.is_ok" title="method core::result::Result::is_ok"><code>is_ok</code></a> and <a href="enum.Result.html#method.is_err" title="method core::result::Result::is_err"><code>is_err</code></a> methods return <a href="../primitive.bool.html" title="primitive bool"><code>true</code></a> if the <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a>
is <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> or <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>, respectively.</p>
<h3 id="adapters-for-working-with-references"><a href="#adapters-for-working-with-references">Adapters for working with references</a></h3>
<ul>
<li><a href="enum.Result.html#method.as_ref" title="method core::result::Result::as_ref"><code>as_ref</code></a> converts from <code>&amp;Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;T, &amp;E&gt;</code></li>
<li><a href="enum.Result.html#method.as_mut" title="method core::result::Result::as_mut"><code>as_mut</code></a> converts from <code>&amp;mut Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;mut T, &amp;mut E&gt;</code></li>
<li><a href="enum.Result.html#method.as_deref" title="method core::result::Result::as_deref"><code>as_deref</code></a> converts from <code>&amp;Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;T::Target, &amp;E&gt;</code></li>
<li><a href="enum.Result.html#method.as_deref_mut" title="method core::result::Result::as_deref_mut"><code>as_deref_mut</code></a> converts from <code>&amp;mut Result&lt;T, E&gt;</code> to
<code>Result&lt;&amp;mut T::Target, &amp;mut E&gt;</code></li>
</ul>
<h3 id="extracting-contained-values"><a href="#extracting-contained-values">Extracting contained values</a></h3>
<p>These methods extract the contained value in a <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> when it
is the <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> variant. If the <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>:</p>
<ul>
<li><a href="enum.Result.html#method.expect" title="method core::result::Result::expect"><code>expect</code></a> panics with a provided custom message</li>
<li><a href="enum.Result.html#method.unwrap" title="method core::result::Result::unwrap"><code>unwrap</code></a> panics with a generic message</li>
<li><a href="enum.Result.html#method.unwrap_or" title="method core::result::Result::unwrap_or"><code>unwrap_or</code></a> returns the provided default value</li>
<li><a href="enum.Result.html#method.unwrap_or_default" title="method core::result::Result::unwrap_or_default"><code>unwrap_or_default</code></a> returns the default value of the type <code>T</code>
(which must implement the <a href="../default/trait.Default.html" title="trait core::default::Default"><code>Default</code></a> trait)</li>
<li><a href="enum.Result.html#method.unwrap_or_else" title="method core::result::Result::unwrap_or_else"><code>unwrap_or_else</code></a> returns the result of evaluating the provided
function</li>
</ul>
<p>The panicking methods <a href="enum.Result.html#method.expect" title="method core::result::Result::expect"><code>expect</code></a> and <a href="enum.Result.html#method.unwrap" title="method core::result::Result::unwrap"><code>unwrap</code></a> require <code>E</code> to
implement the <a href="../fmt/trait.Debug.html" title="trait core::fmt::Debug"><code>Debug</code></a> trait.</p>
<p>These methods extract the contained value in a <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> when it
is the <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> variant. They require <code>T</code> to implement the <a href="../fmt/trait.Debug.html" title="trait core::fmt::Debug"><code>Debug</code></a>
trait. If the <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a>:</p>
<ul>
<li><a href="enum.Result.html#method.expect_err" title="method core::result::Result::expect_err"><code>expect_err</code></a> panics with a provided custom message</li>
<li><a href="enum.Result.html#method.unwrap_err" title="method core::result::Result::unwrap_err"><code>unwrap_err</code></a> panics with a generic message</li>
</ul>
<h3 id="transforming-contained-values"><a href="#transforming-contained-values">Transforming contained values</a></h3>
<p>These methods transform <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> to <a href="../option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a>:</p>
<ul>
<li><a href="enum.Result.html#method.err" title="method core::result::Result::err"><code>err</code></a> transforms <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> into <a href="../option/enum.Option.html" title="enum core::option::Option"><code>Option&lt;E&gt;</code></a>,
mapping <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err(e)</code></a> to <a href="../option/enum.Option.html#variant.Some" title="variant core::option::Option::Some"><code>Some(e)</code></a> and <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok(v)</code></a> to <a href="../option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a></li>
<li><a href="enum.Result.html#method.ok" title="method core::result::Result::ok"><code>ok</code></a> transforms <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> into <a href="../option/enum.Option.html" title="enum core::option::Option"><code>Option&lt;T&gt;</code></a>,
mapping <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok(v)</code></a> to <a href="../option/enum.Option.html#variant.Some" title="variant core::option::Option::Some"><code>Some(v)</code></a> and <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err(e)</code></a> to <a href="../option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a></li>
<li><a href="enum.Result.html#method.transpose" title="method core::result::Result::transpose"><code>transpose</code></a> transposes a <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> of an <a href="../option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a> into an
<a href="../option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a> of a <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a></li>
</ul>
<p>This method transforms the contained value of the <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> variant:</p>
<ul>
<li><a href="enum.Result.html#method.map" title="method core::result::Result::map"><code>map</code></a> transforms <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> into <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;U, E&gt;</code></a> by applying
the provided function to the contained value of <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> and leaving
<a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> values unchanged</li>
</ul>
<p>This method transforms the contained value of the <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> variant:</p>
<ul>
<li><a href="enum.Result.html#method.map_err" title="method core::result::Result::map_err"><code>map_err</code></a> transforms <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> into <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, F&gt;</code></a> by
applying the provided function to the contained value of <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> and
leaving <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> values unchanged</li>
</ul>
<p>These methods transform a <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> into a value of a possibly
different type <code>U</code>:</p>
<ul>
<li><a href="enum.Result.html#method.map_or" title="method core::result::Result::map_or"><code>map_or</code></a> applies the provided function to the contained value of
<a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a>, or returns the provided default value if the <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> is
<a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a></li>
<li><a href="enum.Result.html#method.map_or_else" title="method core::result::Result::map_or_else"><code>map_or_else</code></a> applies the provided function to the contained value
of <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a>, or applies the provided default fallback function to the
contained value of <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a></li>
</ul>
<h3 id="boolean-operators"><a href="#boolean-operators">Boolean operators</a></h3>
<p>These methods treat the <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> as a boolean value, where <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a>
acts like <a href="../primitive.bool.html" title="primitive bool"><code>true</code></a> and <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> acts like <a href="../primitive.bool.html" title="primitive bool"><code>false</code></a>. There are two
categories of these methods: ones that take a <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> as input, and
ones that take a function as input (to be lazily evaluated).</p>
<p>The <a href="enum.Result.html#method.and" title="method core::result::Result::and"><code>and</code></a> and <a href="enum.Result.html#method.or" title="method core::result::Result::or"><code>or</code></a> methods take another <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> as input, and
produce a <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> as output. The <a href="enum.Result.html#method.and" title="method core::result::Result::and"><code>and</code></a> method can produce a
<a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;U, E&gt;</code></a> value having a different inner type <code>U</code> than
<a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a>. The <a href="enum.Result.html#method.or" title="method core::result::Result::or"><code>or</code></a> method can produce a <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, F&gt;</code></a>
value having a different error type <code>F</code> than <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a>.</p>
<div><table><thead><tr><th>method</th><th>self</th><th>input</th><th>output</th></tr></thead><tbody>
<tr><td><a href="enum.Result.html#method.and" title="method core::result::Result::and"><code>and</code></a></td><td><code>Err(e)</code></td><td>(ignored)</td><td><code>Err(e)</code></td></tr>
<tr><td><a href="enum.Result.html#method.and" title="method core::result::Result::and"><code>and</code></a></td><td><code>Ok(x)</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>
<tr><td><a href="enum.Result.html#method.and" title="method core::result::Result::and"><code>and</code></a></td><td><code>Ok(x)</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or" title="method core::result::Result::or"><code>or</code></a></td><td><code>Err(e)</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or" title="method core::result::Result::or"><code>or</code></a></td><td><code>Err(e)</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or" title="method core::result::Result::or"><code>or</code></a></td><td><code>Ok(x)</code></td><td>(ignored)</td><td><code>Ok(x)</code></td></tr>
</tbody></table>
</div>
<p>The <a href="enum.Result.html#method.and_then" title="method core::result::Result::and_then"><code>and_then</code></a> and <a href="enum.Result.html#method.or_else" title="method core::result::Result::or_else"><code>or_else</code></a> methods take a function as input, and
only evaluate the function when they need to produce a new value. The
<a href="enum.Result.html#method.and_then" title="method core::result::Result::and_then"><code>and_then</code></a> method can produce a <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;U, E&gt;</code></a> value having a
different inner type <code>U</code> than <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a>. The <a href="enum.Result.html#method.or_else" title="method core::result::Result::or_else"><code>or_else</code></a> method
can produce a <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, F&gt;</code></a> value having a different error type <code>F</code>
than <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a>.</p>
<div><table><thead><tr><th>method</th><th>self</th><th>function input</th><th>function result</th><th>output</th></tr></thead><tbody>
<tr><td><a href="enum.Result.html#method.and_then" title="method core::result::Result::and_then"><code>and_then</code></a></td><td><code>Err(e)</code></td><td>(not provided)</td><td>(not evaluated)</td><td><code>Err(e)</code></td></tr>
<tr><td><a href="enum.Result.html#method.and_then" title="method core::result::Result::and_then"><code>and_then</code></a></td><td><code>Ok(x)</code></td><td><code>x</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>
<tr><td><a href="enum.Result.html#method.and_then" title="method core::result::Result::and_then"><code>and_then</code></a></td><td><code>Ok(x)</code></td><td><code>x</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or_else" title="method core::result::Result::or_else"><code>or_else</code></a></td><td><code>Err(e)</code></td><td><code>e</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or_else" title="method core::result::Result::or_else"><code>or_else</code></a></td><td><code>Err(e)</code></td><td><code>e</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or_else" title="method core::result::Result::or_else"><code>or_else</code></a></td><td><code>Ok(x)</code></td><td>(not provided)</td><td>(not evaluated)</td><td><code>Ok(x)</code></td></tr>
</tbody></table>
</div><h3 id="comparison-operators"><a href="#comparison-operators">Comparison operators</a></h3>
<p>If <code>T</code> and <code>E</code> both implement <a href="../cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd"><code>PartialOrd</code></a> then <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> will
derive its <a href="../cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd"><code>PartialOrd</code></a> implementation.  With this order, an <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a>
compares as less than any <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>, while two <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> or two <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>
compare as their contained values would in <code>T</code> or <code>E</code> respectively.  If <code>T</code>
and <code>E</code> both also implement <a href="../cmp/trait.Ord.html" title="trait core::cmp::Ord"><code>Ord</code></a>, then so does <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(<span class="prelude-val">Ok</span>(<span class="number">1</span>) &lt; <span class="prelude-val">Err</span>(<span class="number">0</span>));
<span class="kw">let </span>x: <span class="prelude-ty">Result</span>&lt;i32, ()&gt; = <span class="prelude-val">Ok</span>(<span class="number">0</span>);
<span class="kw">let </span>y = <span class="prelude-val">Ok</span>(<span class="number">1</span>);
<span class="macro">assert!</span>(x &lt; y);
<span class="kw">let </span>x: <span class="prelude-ty">Result</span>&lt;(), i32&gt; = <span class="prelude-val">Err</span>(<span class="number">0</span>);
<span class="kw">let </span>y = <span class="prelude-val">Err</span>(<span class="number">1</span>);
<span class="macro">assert!</span>(x &lt; y);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Aassert!(Ok(1)+%3C+Err(0));%0Alet+x:+Result%3Ci32,+()%3E+=+Ok(0);%0Alet+y+=+Ok(1);%0Aassert!(x+%3C+y);%0Alet+x:+Result%3C(),+i32%3E+=+Err(0);%0Alet+y+=+Err(1);%0Aassert!(x+%3C+y);%0A%7D&amp;edition=2021">Run</a></div>
<h3 id="iterating-over-result"><a href="#iterating-over-result">Iterating over <code>Result</code></a></h3>
<p>A <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> can be iterated over. This can be helpful if you need an
iterator that is conditionally empty. The iterator will either produce
a single value (when the <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a>), or produce no values
(when the <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>). For example, <a href="enum.Result.html#method.into_iter" title="method core::result::Result::into_iter"><code>into_iter</code></a> acts like
<a href="../iter/fn.once.html" title="fn core::iter::once"><code>once(v)</code></a> if the <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok(v)</code></a>, and like <a href="../iter/fn.empty.html" title="fn core::iter::empty"><code>empty()</code></a> if the
<a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>.</p>
<p>Iterators over <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> come in three types:</p>
<ul>
<li><a href="enum.Result.html#method.into_iter" title="method core::result::Result::into_iter"><code>into_iter</code></a> consumes the <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> and produces the contained
value</li>
<li><a href="enum.Result.html#method.iter" title="method core::result::Result::iter"><code>iter</code></a> produces an immutable reference of type <code>&amp;T</code> to the
contained value</li>
<li><a href="enum.Result.html#method.iter_mut" title="method core::result::Result::iter_mut"><code>iter_mut</code></a> produces a mutable reference of type <code>&amp;mut T</code> to the
contained value</li>
</ul>
<p>See <a href="../option/index.html#iterating-over-option" title="mod core::option">Iterating over <code>Option</code></a> for examples of how this can be useful.</p>
<p>You might want to use an iterator chain to do multiple instances of an
operation that can fail, but would like to ignore failures while
continuing to process the successful results. In this example, we take
advantage of the iterable nature of <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> to select only the
<a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> values using <a href="../iter/trait.Iterator.html#method.flatten" title="method core::iter::Iterator::flatten"><code>flatten</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>results = <span class="macro">vec!</span>[];
<span class="kw">let </span><span class="kw-2">mut </span>errs = <span class="macro">vec!</span>[];
<span class="kw">let </span>nums: Vec&lt;<span class="kw">_</span>&gt; = [<span class="string">&quot;17&quot;</span>, <span class="string">&quot;not a number&quot;</span>, <span class="string">&quot;99&quot;</span>, <span class="string">&quot;-27&quot;</span>, <span class="string">&quot;768&quot;</span>]
   .into_iter()
   .map(u8::from_str)
   <span class="comment">// Save clones of the raw `Result` values to inspect
   </span>.inspect(|x| results.push(x.clone()))
   <span class="comment">// Challenge: explain how this captures only the `Err` values
   </span>.inspect(|x| errs.extend(x.clone().err()))
   .flatten()
   .collect();
<span class="macro">assert_eq!</span>(errs.len(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(nums, [<span class="number">17</span>, <span class="number">99</span>]);
<span class="macro">println!</span>(<span class="string">&quot;results {results:?}&quot;</span>);
<span class="macro">println!</span>(<span class="string">&quot;errs {errs:?}&quot;</span>);
<span class="macro">println!</span>(<span class="string">&quot;nums {nums:?}&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::str::FromStr;%0Alet+mut+results+=+vec!%5B%5D;%0Alet+mut+errs+=+vec!%5B%5D;%0Alet+nums:+Vec%3C_%3E+=+%5B%2217%22,+%22not+a+number%22,+%2299%22,+%22-27%22,+%22768%22%5D%0A+++.into_iter()%0A+++.map(u8::from_str)%0A+++//+Save+clones+of+the+raw+%60Result%60+values+to+inspect%0A+++.inspect(%7Cx%7C+results.push(x.clone()))%0A+++//+Challenge:+explain+how+this+captures+only+the+%60Err%60+values%0A+++.inspect(%7Cx%7C+errs.extend(x.clone().err()))%0A+++.flatten()%0A+++.collect();%0Aassert_eq!(errs.len(),+3);%0Aassert_eq!(nums,+%5B17,+99%5D);%0Aprintln!(%22results+%7Bresults:?%7D%22);%0Aprintln!(%22errs+%7Berrs:?%7D%22);%0Aprintln!(%22nums+%7Bnums:?%7D%22);%0A%7D&amp;edition=2021">Run</a></div>
<h3 id="collecting-into-result"><a href="#collecting-into-result">Collecting into <code>Result</code></a></h3>
<p><a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> implements the <a href="enum.Result.html#impl-FromIterator%3CResult%3CA,+E%3E%3E-for-Result%3CV,+E%3E" title="enum core::result::Result"><code>FromIterator</code></a> trait,
which allows an iterator over <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> values to be collected into a
<a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> of a collection of each contained value of the original
<a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> values, or <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> if any of the elements was <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = [<span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">4</span>), <span class="prelude-val">Err</span>(<span class="string">&quot;err!&quot;</span>), <span class="prelude-val">Ok</span>(<span class="number">8</span>)];
<span class="kw">let </span>res: <span class="prelude-ty">Result</span>&lt;Vec&lt;<span class="kw">_</span>&gt;, <span class="kw-2">&amp;</span>str&gt; = v.into_iter().collect();
<span class="macro">assert_eq!</span>(res, <span class="prelude-val">Err</span>(<span class="string">&quot;err!&quot;</span>));
<span class="kw">let </span>v = [<span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">4</span>), <span class="prelude-val">Ok</span>(<span class="number">8</span>)];
<span class="kw">let </span>res: <span class="prelude-ty">Result</span>&lt;Vec&lt;<span class="kw">_</span>&gt;, <span class="kw-2">&amp;</span>str&gt; = v.into_iter().collect();
<span class="macro">assert_eq!</span>(res, <span class="prelude-val">Ok</span>(<span class="macro">vec!</span>[<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+v+=+%5BOk(2),+Ok(4),+Err(%22err!%22),+Ok(8)%5D;%0Alet+res:+Result%3CVec%3C_%3E,+%26str%3E+=+v.into_iter().collect();%0Aassert_eq!(res,+Err(%22err!%22));%0Alet+v+=+%5BOk(2),+Ok(4),+Ok(8)%5D;%0Alet+res:+Result%3CVec%3C_%3E,+%26str%3E+=+v.into_iter().collect();%0Aassert_eq!(res,+Ok(vec!%5B2,+4,+8%5D));%0A%7D&amp;edition=2021">Run</a></div>
<p><a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> also implements the <a href="enum.Result.html#impl-Product%3CResult%3CU,+E%3E%3E-for-Result%3CT,+E%3E" title="enum core::result::Result"><code>Product</code></a> and
<a href="enum.Result.html#impl-Sum%3CResult%3CU,+E%3E%3E-for-Result%3CT,+E%3E" title="enum core::result::Result"><code>Sum</code></a> traits, allowing an iterator over <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> values
to provide the <a href="../iter/trait.Iterator.html#method.product" title="method core::iter::Iterator::product"><code>product</code></a> and
<a href="../iter/trait.Iterator.html#method.sum" title="method core::iter::Iterator::sum"><code>sum</code></a> methods.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = [<span class="prelude-val">Err</span>(<span class="string">&quot;error!&quot;</span>), <span class="prelude-val">Ok</span>(<span class="number">1</span>), <span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">3</span>), <span class="prelude-val">Err</span>(<span class="string">&quot;foo&quot;</span>)];
<span class="kw">let </span>res: <span class="prelude-ty">Result</span>&lt;i32, <span class="kw-2">&amp;</span>str&gt; = v.into_iter().sum();
<span class="macro">assert_eq!</span>(res, <span class="prelude-val">Err</span>(<span class="string">&quot;error!&quot;</span>));
<span class="kw">let </span>v = [<span class="prelude-val">Ok</span>(<span class="number">1</span>), <span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">21</span>)];
<span class="kw">let </span>res: <span class="prelude-ty">Result</span>&lt;i32, <span class="kw-2">&amp;</span>str&gt; = v.into_iter().product();
<span class="macro">assert_eq!</span>(res, <span class="prelude-val">Ok</span>(<span class="number">42</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+v+=+%5BErr(%22error!%22),+Ok(1),+Ok(2),+Ok(3),+Err(%22foo%22)%5D;%0Alet+res:+Result%3Ci32,+%26str%3E+=+v.into_iter().sum();%0Aassert_eq!(res,+Err(%22error!%22));%0Alet+v+=+%5BOk(1),+Ok(2),+Ok(21)%5D;%0Alet+res:+Result%3Ci32,+%26str%3E+=+v.into_iter().product();%0Aassert_eq!(res,+Ok(42));%0A%7D&amp;edition=2021">Run</a></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.IntoIter.html" title="struct core::result::IntoIter">IntoIter</a></div><div class="desc docblock-short">An iterator over the value in a <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> variant of a <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Iter.html" title="struct core::result::Iter">Iter</a></div><div class="desc docblock-short">An iterator over a reference to the <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> variant of a <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.IterMut.html" title="struct core::result::IterMut">IterMut</a></div><div class="desc docblock-short">An iterator over a mutable reference to the <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> variant of a <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a>.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Result.html" title="enum core::result::Result">Result</a></div><div class="desc docblock-short"><code>Result</code> is a type that represents either success (<a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a>) or failure (<a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>).</div></li></ul></section></div></main></body></html>